# Comparing `tmp/mdapy-0.8.6-cp39-cp39-win_amd64.whl.zip` & `tmp/mdapy-0.8.7-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 472450 bytes, number of entries: 40
+Zip file size: 472901 bytes, number of entries: 40
 -rw-rw-rw-  2.0 fat   108544 b- defN 23-Apr-22 09:26 _cluster_analysis.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat   110080 b- defN 23-Apr-22 09:26 _neigh.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat   316928 b- defN 23-Apr-22 09:26 _ptm.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat   111616 b- defN 23-Apr-22 09:26 _rdf.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   202240 b- defN 23-Apr-22 09:26 _voronoi_analysis.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     3586 b- defN 23-Apr-12 15:04 mdapy/__init__.py
--rw-rw-rw-  2.0 fat     7836 b- defN 23-Apr-01 12:38 mdapy/ackland_jones_analysis.py
+-rw-rw-rw-  2.0 fat   202240 b- defN 23-May-25 12:45 _voronoi_analysis.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     3586 b- defN 23-May-13 16:54 mdapy/__init__.py
+-rw-rw-rw-  2.0 fat     7822 b- defN 23-May-25 08:45 mdapy/ackland_jones_analysis.py
 -rw-rw-rw-  2.0 fat    10839 b- defN 23-Jan-20 06:31 mdapy/calculator.py
--rw-rw-rw-  2.0 fat     7816 b- defN 23-Apr-10 04:00 mdapy/centro_symmetry_parameter.py
+-rw-rw-rw-  2.0 fat     7754 b- defN 23-May-25 08:45 mdapy/centro_symmetry_parameter.py
 -rw-rw-rw-  2.0 fat     4431 b- defN 23-Apr-22 08:31 mdapy/cluser_analysis.py
--rw-rw-rw-  2.0 fat    10198 b- defN 23-Apr-09 08:41 mdapy/common_neighbor_analysis.py
+-rw-rw-rw-  2.0 fat    10192 b- defN 23-May-13 16:47 mdapy/common_neighbor_analysis.py
 -rw-rw-rw-  2.0 fat     6576 b- defN 23-Feb-22 06:10 mdapy/common_neighbor_parameter.py
 -rw-rw-rw-  2.0 fat    27216 b- defN 23-Apr-22 08:24 mdapy/create_polycrystalline.py
 -rw-rw-rw-  2.0 fat     5528 b- defN 23-Apr-01 13:00 mdapy/eam_average.py
 -rw-rw-rw-  2.0 fat    21039 b- defN 23-Jan-20 06:31 mdapy/eam_generate.py
 -rw-rw-rw-  2.0 fat     9960 b- defN 23-Jan-20 06:31 mdapy/entropy.py
 -rw-rw-rw-  2.0 fat    11015 b- defN 23-Apr-01 13:00 mdapy/identify_SFs_TBs.py
 -rw-rw-rw-  2.0 fat     6831 b- defN 23-Mar-11 08:28 mdapy/kdtree.py
 -rw-rw-rw-  2.0 fat    10077 b- defN 23-Apr-01 06:40 mdapy/lattice_maker.py
--rw-rw-rw-  2.0 fat     8475 b- defN 23-Apr-01 13:02 mdapy/lindemann_parameter.py
--rw-rw-rw-  2.0 fat     7154 b- defN 23-Apr-01 13:07 mdapy/mean_squared_displacement.py
--rw-rw-rw-  2.0 fat    11369 b- defN 23-Apr-01 13:08 mdapy/neighbor.py
--rw-rw-rw-  2.0 fat     9048 b- defN 23-Apr-01 13:09 mdapy/pair_distribution.py
+-rw-rw-rw-  2.0 fat     8459 b- defN 23-May-25 08:49 mdapy/lindemann_parameter.py
+-rw-rw-rw-  2.0 fat     7142 b- defN 23-May-25 08:49 mdapy/mean_squared_displacement.py
+-rw-rw-rw-  2.0 fat    11346 b- defN 23-May-25 08:47 mdapy/neighbor.py
+-rw-rw-rw-  2.0 fat     9036 b- defN 23-May-25 08:46 mdapy/pair_distribution.py
 -rw-rw-rw-  2.0 fat     3082 b- defN 23-Jan-24 04:17 mdapy/plotset.py
--rw-rw-rw-  2.0 fat     5227 b- defN 23-Apr-01 13:11 mdapy/polyhedral_template_matching.py
--rw-rw-rw-  2.0 fat    11532 b- defN 23-Apr-01 13:12 mdapy/potential.py
+-rw-rw-rw-  2.0 fat     5215 b- defN 23-May-25 08:46 mdapy/polyhedral_template_matching.py
+-rw-rw-rw-  2.0 fat    11516 b- defN 23-May-25 08:47 mdapy/potential.py
 -rw-rw-rw-  2.0 fat     6995 b- defN 23-Apr-12 12:53 mdapy/replicate.py
--rw-rw-rw-  2.0 fat    10755 b- defN 23-Apr-01 13:13 mdapy/spatial_binning.py
--rw-rw-rw-  2.0 fat    28837 b- defN 23-Apr-01 13:14 mdapy/steinhardt_bond_orientation.py
--rw-rw-rw-  2.0 fat    76307 b- defN 23-Apr-22 08:50 mdapy/system.py
+-rw-rw-rw-  2.0 fat    10735 b- defN 23-May-25 08:50 mdapy/spatial_binning.py
+-rw-rw-rw-  2.0 fat    28819 b- defN 23-May-25 08:50 mdapy/steinhardt_bond_orientation.py
+-rw-rw-rw-  2.0 fat    76634 b- defN 23-May-25 09:01 mdapy/system.py
 -rw-rw-rw-  2.0 fat     7962 b- defN 23-Jan-20 06:31 mdapy/temperature.py
 -rw-rw-rw-  2.0 fat      562 b- defN 23-Jan-20 06:31 mdapy/timer.py
--rw-rw-rw-  2.0 fat     9171 b- defN 23-Apr-01 13:16 mdapy/void_distribution.py
--rw-rw-rw-  2.0 fat     3417 b- defN 23-Apr-22 08:53 mdapy/voronoi_analysis.py
--rw-rw-rw-  2.0 fat     6650 b- defN 23-Apr-01 13:19 mdapy/warren_cowley_parameter.py
--rw-rw-rw-  2.0 fat     1594 b- defN 23-Apr-22 09:26 mdapy-0.8.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat    10571 b- defN 23-Apr-22 09:26 mdapy-0.8.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-22 09:26 mdapy-0.8.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       59 b- defN 23-Apr-22 09:26 mdapy-0.8.6.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3264 b- defN 23-Apr-22 09:26 mdapy-0.8.6.dist-info/RECORD
-40 files, 1214487 bytes uncompressed, 467348 bytes compressed:  61.5%
+-rw-rw-rw-  2.0 fat     9155 b- defN 23-May-25 08:48 mdapy/void_distribution.py
+-rw-rw-rw-  2.0 fat     3716 b- defN 23-Apr-23 11:45 mdapy/voronoi_analysis.py
+-rw-rw-rw-  2.0 fat     6638 b- defN 23-May-25 08:49 mdapy/warren_cowley_parameter.py
+-rw-rw-rw-  2.0 fat     1594 b- defN 23-May-25 12:45 mdapy-0.8.7.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat    11227 b- defN 23-May-25 12:45 mdapy-0.8.7.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-May-25 12:45 mdapy-0.8.7.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       59 b- defN 23-May-25 12:45 mdapy-0.8.7.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3264 b- defN 23-May-25 12:45 mdapy-0.8.7.dist-info/RECORD
+40 files, 1215530 bytes uncompressed, 467799 bytes compressed:  61.5%
```

## zipnote {}

```diff
@@ -99,23 +99,23 @@
 
 Filename: mdapy/voronoi_analysis.py
 Comment: 
 
 Filename: mdapy/warren_cowley_parameter.py
 Comment: 
 
-Filename: mdapy-0.8.6.dist-info/LICENSE
+Filename: mdapy-0.8.7.dist-info/LICENSE
 Comment: 
 
-Filename: mdapy-0.8.6.dist-info/METADATA
+Filename: mdapy-0.8.7.dist-info/METADATA
 Comment: 
 
-Filename: mdapy-0.8.6.dist-info/WHEEL
+Filename: mdapy-0.8.7.dist-info/WHEEL
 Comment: 
 
-Filename: mdapy-0.8.6.dist-info/top_level.txt
+Filename: mdapy-0.8.7.dist-info/top_level.txt
 Comment: 
 
-Filename: mdapy-0.8.6.dist-info/RECORD
+Filename: mdapy-0.8.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mdapy/__init__.py

```diff
@@ -1,12 +1,12 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 __author__ = "mushroomfire aka HerrWu"
-__version__ = "0.8.6"
+__version__ = "0.8.7"
 __license__ = "BSD License"
 
 from .ackland_jones_analysis import AcklandJonesAnalysis
 from .calculator import Calculator
 from .centro_symmetry_parameter import CentroSymmetryParameter
 from .cluser_analysis import ClusterAnalysis
 from .common_neighbor_analysis import CommonNeighborAnalysis
```

## mdapy/ackland_jones_analysis.py

```diff
@@ -1,16 +1,16 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 
-if __name__ == "__main__":
+try:
     from kdtree import kdtree
-else:
+except Exception:
     from .kdtree import kdtree
 
 
 @ti.data_oriented
 class AcklandJonesAnalysis:
     """This class applies Ackland Jones Analysis (AJA) method to identify the lattice structure.
 
@@ -55,15 +55,14 @@
 
         >>> AJA.aja # Check the aja value
     """
 
     def __init__(
         self, pos, box, boundary=[1, 1, 1], verlet_list=None, distance_list=None
     ):
-
         self.pos = pos
         self.box = box
         self.boundary = np.array(boundary)
         self.verlet_list = verlet_list
         self.distance_list = distance_list
         self.structure = ["other", "fcc", "hcp", "bcc", "ico"]
 
@@ -81,15 +80,14 @@
         pos: ti.types.ndarray(dtype=ti.math.vec3),
         box: ti.types.ndarray(),
         boundary: ti.types.ndarray(),
         verlet_list: ti.types.ndarray(),
         distance_list: ti.types.ndarray(),
         aja: ti.types.ndarray(),
     ):
-
         for i in range(pos.shape[0]):
             r0_sq = ti.f64(0.0)
             for j in range(6):
                 r0_sq += distance_list[i, j] ** 2
             r0_sq /= 6.0
             N0, N1 = 0, 0
             for j in range(14):
```

## mdapy/centro_symmetry_parameter.py

```diff
@@ -1,56 +1,58 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
-if __name__ == "__main__":
+
+try:
     from kdtree import kdtree
-else:
+except Exception:
     from .kdtree import kdtree
 
 vec3f32 = ti.types.vector(3, ti.f32)
 vec3f64 = ti.types.vector(3, ti.f64)
 
+
 @ti.data_oriented
 class CentroSymmetryParameter:
-    """This class is used to compute the CentroSymmetry Parameter (CSP), 
+    """This class is used to compute the CentroSymmetry Parameter (CSP),
     which is heluful to recgonize the structure in lattice, such as FCC and BCC.
-    The  CSP is given by: 
-    
-    .. math:: 
-        
-        p_{\mathrm{CSP}} = \sum_{i=1}^{N/2}{|\mathbf{r}_i + \mathbf{r}_{i+N/2}|^2}, 
+    The  CSP is given by:
+
+    .. math::
 
-    where :math:`r_i` and :math:`r_{i+N/2}` are two neighbor vectors from the central atom to a pair of opposite neighbor atoms. 
-    For ideal centrosymmetric crystal, the contributions of all neighbor pairs will be zero. Atomic sites within a defective 
+        p_{\mathrm{CSP}} = \sum_{i=1}^{N/2}{|\mathbf{r}_i + \mathbf{r}_{i+N/2}|^2},
+
+    where :math:`r_i` and :math:`r_{i+N/2}` are two neighbor vectors from the central atom to a pair of opposite neighbor atoms.
+    For ideal centrosymmetric crystal, the contributions of all neighbor pairs will be zero. Atomic sites within a defective
     crystal region, in contrast, typically have a positive CSP value.
-    
-    This parameter :math:`N` indicates the number of nearest neighbors that should be taken into account when computing 
+
+    This parameter :math:`N` indicates the number of nearest neighbors that should be taken into account when computing
     the centrosymmetry value for an atom. Generally, it should be a positive, even integer. Note that larger number decreases the
     calculation speed. For FCC is 12 and BCC is 8.
 
     .. note:: If you use this module in publication, you should also cite the original paper.
-      `Kelchner C L, Plimpton S J, Hamilton J C. Dislocation nucleation and defect 
+      `Kelchner C L, Plimpton S J, Hamilton J C. Dislocation nucleation and defect
       structure during surface indentation[J]. Physical review B, 1998, 58(17): 11085. <https://journals.aps.org/prb/abstract/10.1103/PhysRevB.58.11085>`_.
 
-    .. hint:: The CSP is calculated by the `same algorithm as LAMMPS <https://docs.lammps.org/compute_centro_atom.html>`_. 
+    .. hint:: The CSP is calculated by the `same algorithm as LAMMPS <https://docs.lammps.org/compute_centro_atom.html>`_.
       First calculate all :math:`N (N - 1) / 2` pairs of neighbor atoms, and the summation of the :math:`N/2` lowest weights
       is CSP values.
 
     Args:
         N (int): Neighbor number.
         pos (np.ndarray): (:math:`N_p, 3`) particles positions.
-        box (np.ndarray): (:math:`3, 2`) system box. 
+        box (np.ndarray): (:math:`3, 2`) system box.
         boundary (list, optional): boundary conditions, 1 is periodic and 0 is free boundary. Defaults to [1, 1, 1].
         verlet_list (np.ndarray, optional): (:math:`N_p`, >=N), first N neighbors is sorted, if not given, use kdtree to obtain it. Defaults to None.
-    
+
     Outputs:
         - **csp** (np.ndarray) - (:math:`N_p`) CSP value per atoms.
-    
+
     Examples:
 
         >>> import mdapy as mp
 
         >>> mp.init()
 
         >>> FCC = mp.LatticeMaker(3.615, 'FCC', 10, 10, 10) # Create a FCC structure
@@ -59,99 +61,100 @@
 
         >>> CSP = mp.CentroSymmetryParameter(12, FCC.pos, FCC.box, [1, 1, 1]) # Initialize CSP class
 
         >>> CSP.compute() # Calculate the csp per atoms
 
         >>> CSP.csp # Check the csp value
     """
-    def __init__(self, N, pos, box, boundary=[1,1,1], verlet_list=None):
-        
+
+    def __init__(self, N, pos, box, boundary=[1, 1, 1], verlet_list=None):
         self.N = N
         self.pos = pos
         self.box = box
-        self.boundary = ti.Vector([boundary[i] for i in range(3)], int)
+        self.boundary = ti.Vector([int(boundary[i]) for i in range(3)])
         if self.pos.dtype == np.float64:
             self.box_length = vec3f64([box[i, 1] - box[i, 0] for i in range(3)])
         elif self.pos.dtype == np.float32:
             self.box_length = vec3f32([box[i, 1] - box[i, 0] for i in range(3)])
         self.half_box_length = self.box_length / 2.0
         self.verlet_list = verlet_list
-    
+
     @ti.func
     def _pbc(self, rij):
-
         for m in ti.static(range(3)):
             if self.boundary[m]:
                 dx = rij[m]
                 x_size = self.box_length[m]
                 h_x_size = self.half_box_length[m]
                 if dx > h_x_size:
                     dx = dx - x_size
                 if dx <= -h_x_size:
                     dx = dx + x_size
                 rij[m] = dx
         return rij
 
     @ti.kernel
-    def _get_csp(self, pair:ti.types.ndarray(), 
-                  pos:ti.types.ndarray(dtype=ti.math.vec3), 
-                  verlet_list:ti.types.ndarray(),  
-                  loop_index:ti.types.ndarray(), 
-                  csp:ti.types.ndarray()):
-
+    def _get_csp(
+        self,
+        pair: ti.types.ndarray(),
+        pos: ti.types.ndarray(dtype=ti.math.vec3),
+        verlet_list: ti.types.ndarray(),
+        loop_index: ti.types.ndarray(),
+        csp: ti.types.ndarray(),
+    ):
         # Get loop index
         num = 0
         ti.loop_config(serialize=True)
         for i in range(self.N):
-            for j in range(i+1, self.N):
+            for j in range(i + 1, self.N):
                 loop_index[num, 0] = i
                 loop_index[num, 1] = j
                 num += 1
-    
+
         for i, index in ti.ndrange(pair.shape[0], pair.shape[1]):
             j = loop_index[index, 0]
             k = loop_index[index, 1]
             rij = pos[verlet_list[i, j]] - pos[i]
             rik = pos[verlet_list[i, k]] - pos[i]
             rij = self._pbc(rij)
             rik = self._pbc(rik)
-            pair[i, index] = (rij+rik).norm_sqr()
+            pair[i, index] = (rij + rik).norm_sqr()
 
         # Select sort
         for i in range(pair.shape[0]):
-            res = ti.f64(0.)
-            for j in range(int(self.N/2)):
+            res = ti.f64(0.0)
+            for j in range(int(self.N / 2)):
                 minIndex = j
-                for k in range(j+1, pair.shape[1]):
+                for k in range(j + 1, pair.shape[1]):
                     if pair[i, k] < pair[i, minIndex]:
                         minIndex = k
                 if minIndex != j:
                     pair[i, minIndex], pair[i, j] = pair[i, j], pair[i, minIndex]
                 res += pair[i, j]
             csp[i] = res
-        
+
     def compute(self):
-        """Do the real CSP calculation.
-        """
-        assert self.pos.shape[0] > self.N 
+        """Do the real CSP calculation."""
+        assert self.pos.shape[0] > self.N
 
         verlet_list = self.verlet_list
         if verlet_list is None:
             kdt = kdtree(self.pos, self.box, self.boundary)
             _, verlet_list = kdt.query_nearest_neighbors(self.N)
-        loop_index = np.zeros((int(self.N*(self.N-1)/2), 2), dtype=int)
-        pair = np.zeros((self.pos.shape[0], int(self.N*(self.N-1)/2)))
+        loop_index = np.zeros((int(self.N * (self.N - 1) / 2), 2), dtype=int)
+        pair = np.zeros((self.pos.shape[0], int(self.N * (self.N - 1) / 2)))
         self.csp = np.zeros(self.pos.shape[0])
         self._get_csp(pair, self.pos, verlet_list, loop_index, self.csp)
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     from lattice_maker import LatticeMaker
     from neighbor import Neighbor
     from time import time
+
     # ti.init(ti.gpu, device_memory_GB=5.0)
     ti.init(ti.cpu)
     start = time()
     lattice_constant = 4.05
     x, y, z = 100, 100, 250
     FCC = LatticeMaker(lattice_constant, "FCC", x, y, z)
     FCC.compute()
@@ -167,36 +170,37 @@
     # end = time()
     # print(f'numpy sort time: {end-start} s.')
     # print(verlet_list_sort[0])
 
     start = time()
     Neigh.sort_verlet_by_distance(12)
     end = time()
-    print(f'taichi sort time: {end-start} s.')
+    print(f"taichi sort time: {end-start} s.")
     print(Neigh.verlet_list[0, :12])
     print(Neigh.distance_list[0, :12])
 
     # start = time()
     # kdt = kdtree(FCC.pos, FCC.box, [1, 1, 1])
     # _, verlet_list_kdt = kdt.query_nearest_neighbors(12)
     # end = time()
     # print(f'kdt time: {end-start} s.')
     # print(verlet_list_kdt[0])
 
     start = time()
     CSP = CentroSymmetryParameter(12, FCC.pos, FCC.box, [1, 1, 1])
     CSP.compute()
-    csp = CSP.csp 
+    csp = CSP.csp
     end = time()
     print(f"Cal csp kdt time: {end-start} s.")
     print(csp[:10])
     print(csp.min(), csp.max(), csp.mean())
 
     start = time()
-    CSP = CentroSymmetryParameter(12, FCC.pos, FCC.box, [1, 1, 1], verlet_list=Neigh.verlet_list)
+    CSP = CentroSymmetryParameter(
+        12, FCC.pos, FCC.box, [1, 1, 1], verlet_list=Neigh.verlet_list
+    )
     CSP.compute()
-    csp = CSP.csp 
+    csp = CSP.csp
     end = time()
     print(f"Cal csp verlet time: {end-start} s.")
     print(csp[:10])
     print(csp.min(), csp.max(), csp.mean())
-
```

## mdapy/common_neighbor_analysis.py

```diff
@@ -82,20 +82,19 @@
         >>> CNA.pattern # Check results, should be 1 here.
 
         >>> CNA.structure[CNA.pattern[0]] # Structure of atom 0, should be fcc here.
 
     """
 
     def __init__(self, rc, verlet_list, neighbor_number, pos, box, boundary=[1, 1, 1]):
-
         self.rc = rc
         self.verlet_list = verlet_list
         self.neighbor_number = neighbor_number
         self.box = box
-        self.boundary = ti.Vector([boundary[i] for i in range(3)], int)
+        self.boundary = ti.Vector([int(boundary[i]) for i in range(3)])
         assert pos.dtype in [
             np.float64,
             np.float32,
         ], "Dtype of pos must in [float64, float32]."
         self.pos = pos
         if self.pos.dtype == np.float64:
             self.box_length = vec3f64([box[i, 1] - box[i, 0] for i in range(3)])
@@ -105,15 +104,14 @@
         self.MAXNEAR = 14
         self.MAXCOMMON = 7
 
         self.structure = ["other", "fcc", "hcp", "bcc", "ico"]
 
     @ti.func
     def _pbc(self, rij):
-
         for m in ti.static(range(3)):
             if self.boundary[m]:
                 dx = rij[m]
                 x_size = self.box_length[m]
                 h_x_size = x_size * 0.5
                 if dx > h_x_size:
                     dx = dx - x_size
@@ -237,15 +235,14 @@
             common,
             bonds,
             self.pattern,
         )
 
 
 if __name__ == "__main__":
-
     from lattice_maker import LatticeMaker
     from neighbor import Neighbor
     from time import time
 
     # ti.init(ti.gpu, device_memory_GB=5.0)
     ti.init(ti.cpu)
     start = time()
```

## mdapy/lindemann_parameter.py

```diff
@@ -2,17 +2,17 @@
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from .plotset import pltset, cm2inch
 
 
 @ti.data_oriented
 class LindemannParameter:
     """This class is used to calculate the `Lindemann index <https://en.wikipedia.org/wiki/Lindemann_index>`_,
     which is useful to distinguish the melt process and determine the melting points of nano-particles.
@@ -65,27 +65,25 @@
         >>> LDML.lindemann_frame # Check Lindemann index per frame.
 
         >>> LDML.plot() # Plot the evolution of Lindemann index per frame.
 
     """
 
     def __init__(self, pos_list, only_global=False) -> None:
-
         self.pos_list = pos_list
         self.only_global = only_global
         self.if_compute = False
 
     @ti.kernel
     def _compute_global(
         self,
         pos_list: ti.types.ndarray(dtype=ti.math.vec3),
         pos_mean: ti.types.ndarray(),
         pos_variance: ti.types.ndarray(),
     ) -> float:
-
         Nframes, Natoms = pos_list.shape
         factor = Natoms * (Natoms - 1) / 2
         for i, j in ti.ndrange(Natoms, Natoms):
             if j > i:
                 for frame in range(Nframes):
                     rijdis = (pos_list[frame, i] - pos_list[frame, j]).norm()
                     pos_mean[i, j] += rijdis
@@ -105,15 +103,14 @@
         self,
         pos_list: ti.types.ndarray(dtype=ti.math.vec3),
         pos_mean: ti.types.ndarray(dtype=float),
         pos_variance: ti.types.ndarray(dtype=float),
         lindemann_frame: ti.types.ndarray(dtype=float),
         lindemann_atom: ti.types.ndarray(dtype=float),
     ):
-
         Nframes, Natoms = pos_list.shape
         ti.loop_config(serialize=True)  # serial compute
         for frame in range(Nframes):
             for i in range(Natoms):
                 for j in range(i + 1, Natoms):
                     rij = pos_list[frame, i] - pos_list[frame, j]
                     rijdis = rij.norm()
```

## mdapy/mean_squared_displacement.py

```diff
@@ -1,16 +1,16 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import numpy as np
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from .plotset import pltset, cm2inch
 
 try:
     import pyfftw
 
     def fft(x, n, axis):
         # FFT wrapper of pyfftw.
@@ -82,15 +82,14 @@
 
         >>> MSD.particle_msd.shape # Check msd per particle, should be (200, 1000) here.
 
         >>> MSD.plot() # Plot the evolution of msd per frame.
     """
 
     def __init__(self, pos_list, mode="windows"):
-
         self.pos_list = pos_list
         assert len(self.pos_list.shape) == 3
         self.mode = mode
         assert self.mode in ["windows", "direct"]
         self.if_compute = False
 
     def _autocorrFFT(self, x):
```

## mdapy/neighbor.py

```diff
@@ -1,16 +1,16 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 
-if __name__ == "__main__":
+try:
     from neigh._neigh import _build_cell
-else:
+except Exception:
     from _neigh import _build_cell
 
 vec3f32 = ti.types.vector(3, ti.f32)
 vec3f64 = ti.types.vector(3, ti.f64)
 
 
 @ti.data_oriented
@@ -51,22 +51,21 @@
 
         >>> neigh.distance_list # Check the neighbor distance.
 
         >>> neigh.neighbor_number # Check the neighbor atom number.
     """
 
     def __init__(self, pos, box, rc, boundary=[1, 1, 1], max_neigh=80, exclude=True):
-
         assert pos.dtype in [
             np.float64,
             np.float32,
         ], "Dtype of pos must in [float64, float32]."
         self.pos = pos
         self.box = box
-        self.boundary = ti.Vector([boundary[i] for i in range(3)], int)
+        self.boundary = ti.Vector([int(boundary[i]) for i in range(3)])
         self.N = self.pos.shape[0]
         self.rc = rc
         self.bin_length = self.rc + 0.5
         self._corigin = np.ascontiguousarray(box[:, 0])
         if self.pos.dtype == np.float64:
             self.origin = vec3f64([box[i, 0] for i in range(3)])
             self.box_length = vec3f64([box[i, 1] - box[i, 0] for i in range(3)])
@@ -79,27 +78,26 @@
                 i if i > 3 else 3
                 for i in [
                     int(np.floor((box[i, 1] - box[i, 0]) / self.bin_length))
                     for i in range(box.shape[0])
                 ]
             ]
         )
-        self.ncel = ti.Vector([self._cncel[0], self._cncel[1], self._cncel[2]], int)
+        self.ncel = ti.Vector([self._cncel[0], self._cncel[1], self._cncel[2]])
         self.max_neigh = max_neigh
         self.exclude = exclude
         self.verlet_list = np.zeros((self.N, self.max_neigh), dtype=np.int32) - 1
         self.distance_list = (
             np.zeros((self.N, self.max_neigh), dtype=pos.dtype) + self.rc + 1.0
         )
         self.neighbor_number = np.zeros(self.N, dtype=np.int32)
         self._if_computed = False
 
     @ti.func
     def _pbc(self, rij):
-
         for m in ti.static(range(3)):
             if self.boundary[m]:
                 dx = rij[m]
                 x_size = self.box_length[m]
                 h_x_size = x_size * 0.5
                 if dx > h_x_size:
                     dx = dx - x_size
@@ -175,15 +173,14 @@
     def _build_verlet_list_small(
         self,
         pos: ti.types.ndarray(dtype=ti.math.vec3),
         verlet_list: ti.types.ndarray(),
         distance_list: ti.types.ndarray(),
         neighbor_number: ti.types.ndarray(),
     ):
-
         ti.loop_config(serialize=True)
         for i in range(self.N):
             nindex = 0
             for j in range(self.N):
                 rij = self._pbc(pos[i] - pos[j])
                 rijdis = rij.norm()
                 if self.exclude:
@@ -267,19 +264,19 @@
         self._partition_select_sort(self.verlet_list, self.distance_list, N)
 
 
 if __name__ == "__main__":
     from lattice_maker import LatticeMaker
     from time import time
 
-    # ti.init(ti.gpu, device_memory_GB=4.0)
+    # ti.init(ti.gpu, device_memory_GB=6.0)
     ti.init(ti.cpu)
     start = time()
     lattice_constant = 3.615
-    x, y, z = 100, 100, 125
+    x, y, z = 50, 50, 125
     FCC = LatticeMaker(lattice_constant, "FCC", x, y, z)
     FCC.compute()
     end = time()
     print(f"Build {FCC.pos.shape[0]} atoms FCC time: {end-start} s.")
     start = time()
     neigh = Neighbor(
         FCC.pos,
```

## mdapy/pair_distribution.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import numpy as np
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from rdf._rdf import _rdf, _rdf_single_species
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from _rdf import _rdf, _rdf_single_species
     from .plotset import pltset, cm2inch
 
 
 class PairDistribution:
     """This class is used to calculate the radiul distribution function (RDF),which
     reflects the probability of finding an atom at distance r. The seperate pair-wise
@@ -70,15 +70,14 @@
         >>> gr.plot_partial() # Plot partial RDF.
 
     """
 
     def __init__(
         self, rc, nbin, rho, verlet_list, distance_list, neighbor_number, type_list=None
     ):
-
         self.rc = rc
         self.nbin = nbin
         self.rho = rho
         self.verlet_list = verlet_list
         self.distance_list = distance_list
         self.neighbor_number = neighbor_number
         self.N = self.distance_list.shape[0]
```

## mdapy/polyhedral_template_matching.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 # We highly thanks to Dr. Peter M Larsen for the help on parallelism of this module.
 
 import numpy as np
 
-if __name__ == "__main__":
+try:
     from ptm import _ptm
     from kdtree import kdtree
-else:
+except Exception:
     import _ptm
     from .kdtree import kdtree
 
 
 class PolyhedralTemplateMatching:
     """This class identifies the local structural environment of particles using the Polyhedral Template Matching (PTM) method, which shows greater reliability than e.g. `Common Neighbor Analysis (CNA) <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.common_neighbor_analysis>`_. It can identify the following structure:
 
@@ -71,15 +71,14 @@
         box,
         boundary=[1, 1, 1],
         structure="fcc-hcp-bcc",
         rmsd_threshold=0.1,
         verlet_list=None,
         return_verlet=False,
     ):
-
         self.pos = pos
         self.box = box
         self.boundary = boundary
         self.structure = structure
         structure_list = [
             "fcc",
             "hcp",
```

## mdapy/potential.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import numpy as np
 from scipy.interpolate import InterpolatedUnivariateSpline as spline
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from .plotset import pltset, cm2inch
 
 
 class EAM:
     """This class is used to read/write a embedded-atom method (EAM) potentials.
     The energy of atom :math:`i` is given by:
 
@@ -60,21 +60,19 @@
 
         >>> potential.phi_data # Check pair interaction.
 
         >>> potential.plot() # Plot information of potential.
     """
 
     def __init__(self, filename):
-
         self.filename = filename
         self._read_eam_alloy()
         pltset()
 
     def _read_eam_alloy(self):
-
         file = open(self.filename).readlines()
         self.header = file[:3]
         self.data = []
         for i in file[3:]:
             self.data.extend(i.split())
 
         self.Nelements = int(self.data[0])
@@ -269,14 +267,13 @@
         """Plot :math:`F`, :math:`\\rho`, :math:`\\phi`."""
         self.plot_rho_r()
         self.plot_embded_rho()
         self.plot_phi_r()
 
 
 if __name__ == "__main__":
-
     potential = EAM("./example/CoNiFeAlCu.eam.alloy")
     potential.plot()
 
     # potential.write_eam_alloy()
     # potential = EAM("CoNiFeAlCu.new.eam.alloy")
     # potential = EAM("./example/Al_DFT.eam.alloy")
```

## mdapy/spatial_binning.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from .plotset import pltset, cm2inch
 
 
 @ti.data_oriented
 class SpatialBinning:
     """This class is used to divide particles into different bins and operating on each bin.
     One-dimensional to Three-dimensional binning are supported.
@@ -50,15 +50,14 @@
         >>> binning.coor['x'] # Check the x coordination.
 
         >>> binning.plot(bar_label='x coordination')
 
     """
 
     def __init__(self, pos, direction, vbin, wbin=5.0, operation="mean") -> None:
-
         self.pos = pos
         self.N = self.pos.shape[0]
         assert direction in [
             "x",
             "y",
             "z",
             "xy",
@@ -86,15 +85,14 @@
     def _Binning_sum(
         self,
         pos: ti.types.ndarray(),
         pos_min: ti.types.ndarray(),
         vbin: ti.types.ndarray(),
         res: ti.types.ndarray(),
     ):
-
         for i, j in ti.ndrange(self.N, res.shape[-1]):
             cindex = ti.floor((pos[i] - pos_min[0]) / self.wbin, dtype=ti.i32)
             if j == 0:
                 res[cindex, 0] += 1.0
             else:
                 res[cindex, j] += vbin[i, j - 1]
 
@@ -102,15 +100,14 @@
     def _Binning_mean(
         self,
         pos: ti.types.ndarray(),
         pos_min: ti.types.ndarray(),
         vbin: ti.types.ndarray(),
         res: ti.types.ndarray(),
     ):
-
         for i, j in ti.ndrange(self.N, res.shape[-1]):
             cindex = ti.floor((pos[i] - pos_min[0]) / self.wbin, dtype=ti.i32)
             if j == 0:
                 res[cindex, 0] += 1.0
             else:
                 res[cindex, j] += vbin[i, j - 1]
 
@@ -125,15 +122,14 @@
     def _Binning_min(
         self,
         pos: ti.types.ndarray(),
         pos_min: ti.types.ndarray(),
         vbin: ti.types.ndarray(),
         res: ti.types.ndarray(),
     ):
-
         # init res
         for i, j in ti.ndrange(self.N, (1, res.shape[-1])):
             cindex = ti.floor((pos[i] - pos_min[0]) / self.wbin, dtype=ti.i32)
             res[cindex, j] = vbin[i, j - 1]
         # get min
         ti.loop_config(serialize=True)
         for i in range(self.N):
@@ -147,15 +143,14 @@
     def _Binning_max(
         self,
         pos: ti.types.ndarray(),
         pos_min: ti.types.ndarray(),
         vbin: ti.types.ndarray(),
         res: ti.types.ndarray(),
     ):
-
         # init res
         for i, j in ti.ndrange(self.N, (1, res.shape[-1])):
             cindex = ti.floor((pos[i] - pos_min[0]) / self.wbin, dtype=ti.i32)
             res[cindex, j] = vbin[i, j - 1]
         # get max
         ti.loop_config(serialize=True)
         for i in range(self.N):
```

## mdapy/steinhardt_bond_orientation.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import numpy as np
 import taichi as ti
 
-if __name__ == "__main__":
+try:
     from neighbor import Neighbor
     from kdtree import kdtree
-else:
+except Exception:
     from .neighbor import Neighbor
     from .kdtree import kdtree
 
 nfac_table_numpy = np.array(
     [
         1,
         1,
@@ -288,15 +288,14 @@
         rc=0.0,
         qlist=np.array([4, 6, 8, 10, 12], int),
         nnn=12,
         wlflag=False,
         wlhatflag=False,
         max_neigh=60,
     ):
-
         self.rc = rc
         self.pos = pos
         self.box = box
         self.boundary = np.array(boundary)
         self.verlet_list = verlet_list
         self.distance_list = distance_list
         self.neighbor_number = neighbor_number
@@ -338,15 +337,14 @@
         # if n >= 0 and n < self.nfac_table.shape[0]:
         return self.nfac_table[n]
 
     @ti.kernel
     def _init_clebsch_gordan(
         self, cglist: ti.types.ndarray(), qlist: ti.types.ndarray()
     ):
-
         idxcg_count = 0
         for il in range(self.nqlist):
             l = qlist[il]
             for m1 in range(2 * l + 1):
                 aa2 = m1 - l
                 for m2 in range(ti.max(0, l - m1), ti.min(2 * l + 1, 3 * l - m1 + 1)):
                     bb2 = m2 - l
@@ -621,15 +619,14 @@
         qnm_r: ti.types.ndarray(),
         qnm_i: ti.types.ndarray(),
         neighbor_number: ti.types.ndarray(),
         threshold: float,
         n_bond: int,
         solidliquid: ti.types.ndarray(),
     ):
-
         for i in range(verlet_list.shape[0]):
             n_solid_bond = 0
             for jj in range(neighbor_number[i]):
                 j = verlet_list[i, jj]
                 r = distance_list[i, jj]
                 sij_sum = ti.f64(0.0)
                 if r <= self.rc:
@@ -669,15 +666,14 @@
             threshold,
             n_bond,
             self.solidliquid,
         )
 
 
 if __name__ == "__main__":
-
     from lattice_maker import LatticeMaker
     from time import time
 
     ti.init()
     start = time()
     FCC = LatticeMaker(3.615, "FCC", 50, 50, 50)
     FCC.compute()
```

## mdapy/system.py

```diff
@@ -4,15 +4,15 @@
 import taichi as ti
 import numpy as np
 import pandas as pd
 import pyarrow as pa
 from pyarrow import csv
 import multiprocessing as mt
 
-if __name__ == "__main__":
+try:
     from ackland_jones_analysis import AcklandJonesAnalysis
     from common_neighbor_analysis import CommonNeighborAnalysis
     from common_neighbor_parameter import CommonNeighborParameter
     from neighbor import Neighbor
     from temperature import AtomicTemperature
     from centro_symmetry_parameter import CentroSymmetryParameter
     from entropy import AtomicEntropy
@@ -26,15 +26,15 @@
     from warren_cowley_parameter import WarrenCowleyParameter
     from voronoi_analysis import VoronoiAnalysis
     from mean_squared_displacement import MeanSquaredDisplacement
     from lindemann_parameter import LindemannParameter
     from spatial_binning import SpatialBinning
     from steinhardt_bond_orientation import SteinhardtBondOrientation
     from replicate import Replicate
-else:
+except Exception:
     from .common_neighbor_analysis import CommonNeighborAnalysis
     from .ackland_jones_analysis import AcklandJonesAnalysis
     from .common_neighbor_parameter import CommonNeighborParameter
     from .neighbor import Neighbor
     from .temperature import AtomicTemperature
     from .centro_symmetry_parameter import CentroSymmetryParameter
     from .entropy import AtomicEntropy
@@ -410,14 +410,15 @@
                     self.filename,
                     read_options=read_options,
                     parse_options=parse_options,
                 )
                 .drop(["id"])
                 .to_pandas()
             )
+            assert vel.shape[0] == data.shape[0]
             self.col_names += ["vx", "vy", "vz"]
             self.data = pd.concat([data, vel], axis=1)
             self.vel = vel.values
         except Exception:
             self.data = data
 
         if self.sorted_id:
@@ -1451,17 +1452,18 @@
             self.WarrenCowleyParameter = WarrenCowleyParameter(
                 neigh.verlet_list, neigh.neighbor_number, self.data["type"].values
             )
 
         self.WarrenCowleyParameter.compute()
 
     def cal_voronoi_volume(self, num_t=None):
-        """This class is used to calculate the Voronoi polygon, wchich can be applied to
+        """This class is used to calculate the Voronoi polygon, which can be applied to
         estimate the atomic volume. The calculation is conducted by the `voro++ <https://math.lbl.gov/voro++/>`_ package and
-        this class only provides a wrapper.
+        this class only provides a wrapper. From mdapy v0.8.6, we use extended parallel voro++ to improve the performance, the
+        implementation can be found in `An extension to VORO++ for multithreaded computation of Voronoi cells <https://arxiv.org/abs/2209.11606>`_.
 
         Args:
             num_t (int, optional): threads number to generate Voronoi diagram. If not given, use all avilable threads.
 
         Outputs:
             - **The atomic Voronoi volume is added in self.data['voronoi_volume']**.
             - **The atomic Voronoi neighbor is added in self.data["voronoi_number"]**.
@@ -1664,16 +1666,17 @@
             pass
 
 
 if __name__ == "__main__":
     import taichi as ti
 
     ti.init()
-    # system = System(filename=r"./example/CoCuFeNiPd-4M.data")
-    system = System(filename=r"./example/CoCuFeNiPd-4M.dump")
+    system = System(filename=r"./example/CoCuFeNiPd-4M.data")
+    # system = System(filename=r"./example/CoCuFeNiPd-4M.dump")
+    # system = System(filename=r"E:\HTiHe\relax.data")
     # box = np.array([[0, 10], [0, 10], [0, 10]])
     # pos = np.array([[0.0, 0.0, 0.0], [1.5, 6.5, 9.0]])
     # vel = np.array([[1.0, 0.0, 0.0], [2.5, 6.5, 9.0]])
     # q = np.array([1.0, 2.0])
     # system = System(
     #     box=box,
     #     pos=pos,
```

## mdapy/void_distribution.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 
-if __name__ == "__main__":
+try:
     from neighbor import Neighbor
     from cluser_analysis import ClusterAnalysis
-else:
+except Exception:
     from .neighbor import Neighbor
     from .cluser_analysis import ClusterAnalysis
 
 
 @ti.data_oriented
 class VoidDistribution:
     """This class is used to detect the void distribution in solid structure.
@@ -76,15 +76,14 @@
         box,
         cell_length,
         boundary=[1, 1, 1],
         out_void=False,
         head=None,
         out_name="void.dump",
     ):
-
         self.pos = pos
         self.N = self.pos.shape[0]
         self.box = box
         self.cell_length = cell_length
         self.boundary = boundary
         self.out_void = out_void
         self.head = head
@@ -149,15 +148,14 @@
                 num += id_list[ii, jj, kk]
             if num < 26:  # 26 is empty
                 cell_id_list[iicel, jjcel, kkcel] = 1  # is void
             # else:
             #     cell_id_list[iicel, jjcel, kkcel] = 0  # is point defect
 
     def _write_void_pos(self, void_data):
-
         if self.head is None:
             boundary_str = ["pp" if i == 1 else "ff" for i in self.boundary]
             head = [
                 "ITEM: TIMESTEP\n",
                 "0\n",
                 "ITEM: NUMBER OF ATOMS\n",
                 f"{void_data.shape[0]}\n",
@@ -208,15 +206,14 @@
                 self._write_void_pos(void_data)
         else:
             self.void_number = 0
             self.void_volume = 0.0
 
 
 if __name__ == "__main__":
-
     from lattice_maker import LatticeMaker
     from time import time
 
     # ti.init(ti.gpu, device_memory_GB=5.0)
     ti.init(ti.cpu)
     start = time()
     lattice_constant = 4.05
```

## mdapy/voronoi_analysis.py

```diff
@@ -1,24 +1,26 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
-# We highly thanks to Dr. Jiayin Lu for the help on parallelism of this module.
+# We highly thanks to Dr. Jiayin Lu, Prof. Christipher Rycroft
+# and Prof. Emanuel Lazar for the help on parallelism of this module.
 
 import numpy as np
 import multiprocessing as mt
 
 if __name__ == "__main__":
     from voronoi import _voronoi_analysis
 else:
     import _voronoi_analysis
 
 
 class VoronoiAnalysis:
-    """This class is used to calculate the Voronoi polygon, wchich can be applied to
+    """This class is used to calculate the Voronoi polygon, which can be applied to
     estimate the atomic volume. The calculation is conducted by the `voro++ <https://math.lbl.gov/voro++/>`_ package and
-    this class only provides a wrapper.
+    this class only provides a wrapper. From mdapy v0.8.6, we use extended parallel voro++ to improve the performance, the
+    implementation can be found in `An extension to VORO++ for multithreaded computation of Voronoi cells <https://arxiv.org/abs/2209.11606>`_.
 
     Args:
         pos (np.ndarray): (:math:`N_p, 3`) particles positions.
         box (np.ndarray): (:math:`3, 2`) system box.
         boundary (list): boundary conditions, 1 is periodic and 0 is free boundary, such as [1, 1, 1].
         num_t (int, optional): threads number to generate Voronoi diagram. If not given, use all avilable threads.
 
@@ -77,19 +79,21 @@
 if __name__ == "__main__":
     import taichi as ti
     from lattice_maker import LatticeMaker
     from time import time
 
     ti.init()
 
-    FCC = LatticeMaker(4.05, "FCC", 100, 100, 50)  # Create a FCC structure.
+    FCC = LatticeMaker(4.05, "FCC", 50, 50, 50)  # Create a FCC structure.
     FCC.compute()  # Get atom positions.
     # FCC.write_data()
     start = time()
-    avol = VoronoiAnalysis(FCC.pos, FCC.box, [1, 1, 1])  # Initilize the Voronoi class.
+    avol = VoronoiAnalysis(
+        FCC.pos, FCC.box, [1, 1, 1], 40
+    )  # Initilize the Voronoi class.
     avol.compute()  # Calculate the Voronoi volume.
     end = time()
 
     print(f"Calculate volume time: {end-start} s.")
     print(avol.vol)  # Check atomic Voronoi volume.
     print(avol.neighbor_number)  # Check neighbor number.
     print(avol.cavity_radius)  # Check the cavity radius.
```

## mdapy/warren_cowley_parameter.py

```diff
@@ -1,17 +1,17 @@
 # Copyright (c) 2022, mushroomfire in Beijing Institute of Technology
 # This file is from the mdapy project, released under the BSD 3-Clause License.
 
 import taichi as ti
 import numpy as np
 import matplotlib.pyplot as plt
 
-if __name__ == "__main__":
+try:
     from plotset import pltset, cm2inch
-else:
+except Exception:
     from .plotset import pltset, cm2inch
 
 
 @ti.data_oriented
 class WarrenCowleyParameter:
     """This class is used to calculate the Warren Cowley parameter (WCP), which is useful to
     analyze the short-range order (SRO) in the 1st-nearest neighbor shell in alloy system and is given by:
@@ -54,15 +54,14 @@
 
         This should get the same results with that in paper: `Simultaneously enhancing the ultimate strength and ductility of high-entropy alloys via short-range ordering <https://doi.org/10.1038/s41467-021-25264-5>`_.
 
         >>> wcp.plot(["Co", "Cu", "Fe", "Ni", "Pd"]) # Plot the results.
     """
 
     def __init__(self, verlet_list, neighbor_number, type_list):
-
         self.verlet_list = verlet_list
         self.neighbor_number = neighbor_number
         self.type_list = type_list - 1
         pltset()
 
     @ti.kernel
     def _get_wcp(
```

## Comparing `mdapy-0.8.6.dist-info/LICENSE` & `mdapy-0.8.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mdapy-0.8.6.dist-info/METADATA` & `mdapy-0.8.7.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,45 +1,45 @@
 Metadata-Version: 2.1
 Name: mdapy
-Version: 0.8.6
+Version: 0.8.7
 Summary: A simple, fast and cross-platform python library to handle the data generated from molecular dynamics simulations
 Home-page: https://github.com/mushroomfire/mdapy
 Author: mushroomfire aka HerrWu
 Author-email: yongchao_wu@bit.edu.cn
 License: BSD 3-Clause License
 Project-URL: Homepage, https://github.com/mushroomfire/mdapy
 Project-URL: Documentation, https://mdapy.readthedocs.io/
 Project-URL: Issue Tracker, https://github.com/mushroomfire/mdapy/issues
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Operating System :: MacOS
-Requires-Python: >=3.7,<3.11
+Requires-Python: >=3.7,<=3.11
 License-File: LICENSE
-Requires-Dist: taichi (>=1.4.0)
+Requires-Dist: taichi (>=1.6.0)
 Requires-Dist: numpy
 Requires-Dist: scipy
 Requires-Dist: pandas
 Requires-Dist: pyarrow
 Requires-Dist: matplotlib
 
 .. image:: https://img.pterclub.com/images/2023/01/06/logo.png
 
 *mdapy* : Molecular Dynamics Analysis with Python
 =====================================================
 
 Overview
 --------
 
-The **mdapy** python library is developed by the **Yong-Chao Wu & Jian-Li Shao Group at the 
-Beijing Institute of Technology**, which provides an array of powerful, flexible, and straightforward 
+The **mdapy** python library provides an array of powerful, flexible, and straightforward 
 tools to analyze atomic trajectories generated from Molecular Dynamics (MD) simulations. The library is fully 
 cross-platform, making it accessible to users in **Windows, Linux, and Mac OS**. 
 Benefited by the `TaiChi <https://github.com/taichi-dev/taichi>`_ project, 
 we can effectively accelerate the pure python code, bringing it closer to the speed of code written in C++. 
 Furthermore, **mdapy** is highly parallelized, allowing users to leverage the resources of both multicore CPU and GPU. 
 **mdapy** can directly handle the DUMP and DATA formats in `LAMMPS <https://www.lammps.org/>`_. 
 Besides, all data in **mdapy** is stored in NDARRAY format in `NumPy <https://numpy.org/>`_\ , which enables easy integration 
@@ -53,16 +53,16 @@
 - Homepage: `https://github.com/mushroomfire/mdapy <https://github.com/mushroomfire/mdapy>`_
 - Documentation: `https://mdapy.readthedocs.io/ <https://mdapy.readthedocs.io/>`_
 - Issue Tracker: `https://github.com/mushroomfire/mdapy/issues <https://github.com/mushroomfire/mdapy/issues>`_
 
 Dependencies
 ------------
 
-* `python <https://www.python.org/>`_ (3.7-3.10)
-* `taichi>=1.4.0 <https://github.com/taichi-dev/taichi>`_
+* `python <https://www.python.org/>`_ (3.7-3.11)
+* `taichi>=1.6.0 <https://github.com/taichi-dev/taichi>`_
 * `numpy <https://numpy.org/>`_
 * `scipy <https://scipy.org/>`_
 * `pandas <https://pandas.pydata.org/>`_
 * `pyarrow <https://arrow.apache.org/docs/python/index.html>`_
 * `matplotlib <https://matplotlib.org/>`_
 
 Optional Dependencies
@@ -155,31 +155,39 @@
    - `Neighbor Atoms within Fixed Distance <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.neighbor>`_
    - `Neighbor Atoms within Fixed Number <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.kdtree>`_
 
 6. Other 
 
    - `Void Distribution <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.void_distribution>`_
    - `Cluster Analysis <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.cluser_analysis>`_
+   - `Replication <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.replicate>`_
    - `Warren Cowley Parameter <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.warren_cowley_parameter>`_
    - `Average Atomic Temperature <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.temperature>`_
    - `Atomic Voronoi Volume <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.voronoi_analysis>`_
    - `Multi-dimensional Spatial Binning <https://mdapy.readthedocs.io/en/latest/mdapy.html#module-mdapy.spatial_binning>`_
 
 
 Citation
 ---------
-If you find **mdapy** useful, you can start it!
-If you use **mdapy** in your scientific publication, because the paper is under
-review on *Computer Physics Communication* and you can cite its preprint version as below:
+If you find **mdapy** useful, you can `star it! <https://github.com/mushroomfire/mdapy>`_
+If you use **mdapy** in your scientific publications, please `cite the paper: <https://doi.org/10.1016/j.cpc.2023.108764>`_
 
-.. code-block:: bash
+.. code-block:: bibtex
 
-   Wu, Yong-Chao and Shao, Jian-Li, Mdapy: A Flexible and Efficient Analysis Software for 
-   Molecular Dynamics Simulations. Available at SSRN: https://ssrn.com/abstract=4360931 
-   or http://dx.doi.org/10.2139/ssrn.4360931.
+   @article{mdapy2023,
+      title = {mdapy: A flexible and efficient analysis software for molecular dynamics simulations},
+      journal = {Computer Physics Communications},
+      pages = {108764},
+      year = {2023},
+      issn = {0010-4655},
+      doi = {https://doi.org/10.1016/j.cpc.2023.108764},
+      url = {https://www.sciencedirect.com/science/article/pii/S0010465523001091},
+      author = {Yong-Chao Wu and Jian-Li Shao},
+      keywords = {Simulation analysis, Molecular dynamics, Polycrystal, TaiChi, Parallel computing}
+      }
 
 
 Trouble Shoot
 -------------
 
 If you encounter ImportError in Linux: 
 
@@ -191,14 +199,21 @@
 
 .. code-block:: bash
 
    conda install -c conda-forge gxx_linux-64
 
 Release Notes
 --------------
+V0.8.7 (5/25/2023)
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+- Updated Taichi to 1.6.0, which decreases the import time ans supports Python 3.11.
+- Fix bug in read data.
+- Updated mdapy citation. We are pleased that our article for mdapy has been accepted by **Computer Physics Communications**.
+
 V0.8.6 (4/22/2023)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 - Add repr for System class.
 - Add Replicate class.
 - Improve the performance of **reading/writing DATA file with pyarrow**.
 - Improve the performance of **building Voronoi diagram** with new version voro++.
```

## Comparing `mdapy-0.8.6.dist-info/RECORD` & `mdapy-0.8.7.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 _cluster_analysis.cp39-win_amd64.pyd,sha256=fh1WzlcjYxbbIQdoIpd_UwD6kqfW_kTsNZZRqKJzeW4,108544
 _neigh.cp39-win_amd64.pyd,sha256=JTou0JHRzIgFTrX4AnKG9iWjeFPWrKk-5j2aSoa2ikw,110080
 _ptm.cp39-win_amd64.pyd,sha256=6B5oWasUzi5jA0fKy7AtPL_fy0ozn99mpl5tfXh46rY,316928
 _rdf.cp39-win_amd64.pyd,sha256=b0tfQKnkmsSq7jr8ZK2rBGNT4EOjBYXUNGXP2q3eeNA,111616
-_voronoi_analysis.cp39-win_amd64.pyd,sha256=ivc5pHOU7M27HmbiOHRs5o5k7qjIE83wob8zD6HgqJs,202240
-mdapy/__init__.py,sha256=-mM4CjZF48AhcvOxUZnWx9ehOzE7fKFj2dde3BNh7xM,3586
-mdapy/ackland_jones_analysis.py,sha256=BYqqB7r--tUzEI0FJ1zpyimu4Ol_zffj8-e5MRN3zP4,7836
+_voronoi_analysis.cp39-win_amd64.pyd,sha256=mT-5YQx1Poj7-R_KQ2bRCNsrCKYUDm8ftBiXb4Rm1LQ,202240
+mdapy/__init__.py,sha256=NrqnVNeFJyZkUc0gjy2dyOuRYiMrgZYOJfVUJ5sxlfU,3586
+mdapy/ackland_jones_analysis.py,sha256=GHLAhhfr6Q2LTnzgWIYXeZ64KTMT1AWlQbWpS9_dC4I,7822
 mdapy/calculator.py,sha256=X-sr0TXd4qWbnZAuIm_cvJxaRRzjL99cTmipgcLdTbk,10839
-mdapy/centro_symmetry_parameter.py,sha256=aZqkpAXZJMC8dnK0T7sQBNpoJiuiBUcL7uiuuY_1mJU,7816
+mdapy/centro_symmetry_parameter.py,sha256=8DIOMtEmysP7R8t-6Wb4n34LyPKdJDByWZQmYbcuEe0,7754
 mdapy/cluser_analysis.py,sha256=59EoLqCf12kXaMbpW7kmY5R-jRYb6ck85S5jBXBQ1_o,4431
-mdapy/common_neighbor_analysis.py,sha256=cdWmWN59N-OIAkv7Jl27cQQ7p7eI82gbSa1RpQ--rGQ,10198
+mdapy/common_neighbor_analysis.py,sha256=XZL7fL16ML8B6eFq6CqnmWKSk7JXVQ35TRkVtfQ5Fhg,10192
 mdapy/common_neighbor_parameter.py,sha256=WOyNKfXCpiCT5xXO3LF1eoE_5ZXg-OonW1eXlGfNZUE,6576
 mdapy/create_polycrystalline.py,sha256=QXmnN643py_A2XaDCQb38Hz4f56xg_RMQk67bJNlhI0,27216
 mdapy/eam_average.py,sha256=lbAFzKlrVeirRTC6gNkWbQhpSi7BzmnJywNg2DxoySw,5528
 mdapy/eam_generate.py,sha256=IcX7JzkvZ_sdPWfnebsJitAeVJtX5tberxo28opYc6g,21039
 mdapy/entropy.py,sha256=lgvAKBrEtw58dnDUaIrViFaT_i8X5CDPfLKhmzkzrtI,9960
 mdapy/identify_SFs_TBs.py,sha256=EoSp1vPDkmOe8V9VEzD7Mw6Wv0C8XrYdfyUC8Dhb4Ko,11015
 mdapy/kdtree.py,sha256=rmUHjneSk90kom9hU3OnjRlSkciYP30FdCciTMVg3Lc,6831
 mdapy/lattice_maker.py,sha256=8drw-nyU12FvAHmfQTZjK-A8FSvfeC-X6xRTDokj5LY,10077
-mdapy/lindemann_parameter.py,sha256=CeYKjoSwmEI469onbVVQIGgn9Y-XPemg97fGxk7aYWA,8475
-mdapy/mean_squared_displacement.py,sha256=_siQGQWSVVRb2RrFQmx-acM6V9kRc3WOWZKjNs8W7O8,7154
-mdapy/neighbor.py,sha256=mxKu-XFLq00Y8Lt3htbpxi_coSV_7QSmUgkOoH5mLTE,11369
-mdapy/pair_distribution.py,sha256=XCS9rgJnxXpuhY_RRqmxPzb4Yqt1_uXgVtjXlFT-wCs,9048
+mdapy/lindemann_parameter.py,sha256=_86_rYkXkH09lwQn8ypa9ch0iHfVkKu0pSqNA-i06qM,8459
+mdapy/mean_squared_displacement.py,sha256=FaJVYt_UDb97lI4d_1uPWVljjcP1CcPB3E6FtE9Mca8,7142
+mdapy/neighbor.py,sha256=gtQt6YZrHbtttbG646J7WLi8bpSmnP6uJEBpOo8p-Kc,11346
+mdapy/pair_distribution.py,sha256=bZZQcHDy7gW1UqHGymgK_IrqIXo1dfgmnGXjFgPDIqs,9036
 mdapy/plotset.py,sha256=Np6sbBB8mtiJU_crowYn1eGgHJ0LYkEOyBn-ImR_0pE,3082
-mdapy/polyhedral_template_matching.py,sha256=E59tevHmMwxeN7648hBIpKdAJsWDiMMy92TnDz6-60g,5227
-mdapy/potential.py,sha256=mM9vkO3TYrj4iub72QcsC3nwBcsBJe1gAVscmSmGceI,11532
+mdapy/polyhedral_template_matching.py,sha256=HO3hwD44i5euqYmahtznxRLNi-uLAz3wDQMa35VzmMQ,5215
+mdapy/potential.py,sha256=XFg183BcFKy3hANhacyYZlhniuciMvwdDcPjt-irXsY,11516
 mdapy/replicate.py,sha256=-4n5rVSAD1r_4Z3ahfeRwh6Wr3ovKu4QP-l9pdT-aMY,6995
-mdapy/spatial_binning.py,sha256=SolPl_NWCAB1yig02Qs4STc6e7OfSuYiGyB_8Yaz2cU,10755
-mdapy/steinhardt_bond_orientation.py,sha256=EpUpvcef614Iz_vuduCcY6IXM6TovWY6ofOTvZXhgBk,28837
-mdapy/system.py,sha256=UAQRJV9vBKG764rnvxDbrGUE7IK1jKi1Rqc_FGDJOnU,76307
+mdapy/spatial_binning.py,sha256=u17LiHUggRoV6aovST0q9TMgqmST1djYirc3y7PXidA,10735
+mdapy/steinhardt_bond_orientation.py,sha256=G1RSM_WRjxd8XhZ1k3iURzHnAZddg8TjVrG0HnZxSE0,28819
+mdapy/system.py,sha256=-aSJQdTNcI8cv3pRbihnsaJ8_U7N0pi94h2NHg0oyvA,76634
 mdapy/temperature.py,sha256=vBpbR-5Sypop5bWeYMFrUOrHIvSTCQiXdBYdxsNGbOI,7962
 mdapy/timer.py,sha256=utfs-GkunB7UQbYckK5Eb2_rUjlttjnG2Gty8asQZz4,562
-mdapy/void_distribution.py,sha256=siUzzSWifZPIKLCBErEgK8dJPkk5lFtjHcUmKgJgJGc,9171
-mdapy/voronoi_analysis.py,sha256=yOoBboYfcElUC8wwXn4WYe0zAYjlPVHZy7T9eXzrcog,3417
-mdapy/warren_cowley_parameter.py,sha256=LYK6aJN6aw34ZoO5qML6AhV-ozUPpGre30FiM-Nm1L0,6650
-mdapy-0.8.6.dist-info/LICENSE,sha256=kiAKfZIqcnirr_wG_POuIYajY3Mm6HhFLyDsb-0vMYY,1594
-mdapy-0.8.6.dist-info/METADATA,sha256=g-i1poqMrEoGPxwzNZEIZ0vh-8l89xY38YkZwXn6ISY,10571
-mdapy-0.8.6.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
-mdapy-0.8.6.dist-info/top_level.txt,sha256=Twzc5Zz30D-3WO_3w1ZqgeK7DkzSO4NZIe4PFIJ_T30,59
-mdapy-0.8.6.dist-info/RECORD,,
+mdapy/void_distribution.py,sha256=xUkuFMJ9bE3Hpen7iC3tp1NT4LVgxBras10_ulI3yUQ,9155
+mdapy/voronoi_analysis.py,sha256=G9psb1ngNwGegounWWr7fZzDQFtzx0e-JAqC66mtl9U,3716
+mdapy/warren_cowley_parameter.py,sha256=2KDeZxTUO6ZfaruHBoIH7IW943BsgL6fG2vSGNXzSYI,6638
+mdapy-0.8.7.dist-info/LICENSE,sha256=kiAKfZIqcnirr_wG_POuIYajY3Mm6HhFLyDsb-0vMYY,1594
+mdapy-0.8.7.dist-info/METADATA,sha256=DoUY8bhaBKJMKoRUdMKyyRgVQQttpn7sd-NUkFrgF1o,11227
+mdapy-0.8.7.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
+mdapy-0.8.7.dist-info/top_level.txt,sha256=Twzc5Zz30D-3WO_3w1ZqgeK7DkzSO4NZIe4PFIJ_T30,59
+mdapy-0.8.7.dist-info/RECORD,,
```

