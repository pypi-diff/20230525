# Comparing `tmp/dscan_api_client-1.0.0-py3-none-any.whl.zip` & `tmp/dscan_api_client-1.0.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,70 +1,70 @@
-Zip file size: 64871 bytes, number of entries: 68
--rw-r--r--  2.0 unx      153 b- defN 23-May-22 20:55 dscan_api_client/__init__.py
--rw-r--r--  2.0 unx     2817 b- defN 23-May-22 20:55 dscan_api_client/client.py
--rw-r--r--  2.0 unx      470 b- defN 23-May-22 20:55 dscan_api_client/errors.py
--rw-r--r--  2.0 unx       25 b- defN 23-May-22 20:55 dscan_api_client/py.typed
--rw-r--r--  2.0 unx      993 b- defN 23-May-22 20:55 dscan_api_client/types.py
--rw-r--r--  2.0 unx       47 b- defN 23-May-22 20:55 dscan_api_client/api/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/programs/__init__.py
--rw-r--r--  2.0 unx     4577 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_create.py
--rw-r--r--  2.0 unx     2556 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_destroy.py
--rw-r--r--  2.0 unx     3666 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_list.py
--rw-r--r--  2.0 unx     5000 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_partial_update.py
--rw-r--r--  2.0 unx     3650 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_retrieve.py
--rw-r--r--  2.0 unx     4128 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_search_list.py
--rw-r--r--  2.0 unx     3465 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_subdomain_check_create.py
--rw-r--r--  2.0 unx     5533 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_subdomain_get_details_list.py
--rw-r--r--  2.0 unx     5393 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_subdomain_get_list.py
--rw-r--r--  2.0 unx     4784 b- defN 23-May-22 20:55 dscan_api_client/api/programs/programs_update.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/scans/__init__.py
--rw-r--r--  2.0 unx     4466 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_create.py
--rw-r--r--  2.0 unx     2553 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_destroy.py
--rw-r--r--  2.0 unx     3624 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_list.py
--rw-r--r--  2.0 unx     4883 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_partial_update.py
--rw-r--r--  2.0 unx     3608 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_retrieve.py
--rw-r--r--  2.0 unx     4673 b- defN 23-May-22 20:55 dscan_api_client/api/scans/scans_update.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/settings/__init__.py
--rw-r--r--  2.0 unx     4577 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_create.py
--rw-r--r--  2.0 unx     2556 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_destroy.py
--rw-r--r--  2.0 unx     3666 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_list.py
--rw-r--r--  2.0 unx     5000 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_partial_update.py
--rw-r--r--  2.0 unx     3650 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_retrieve.py
--rw-r--r--  2.0 unx     4784 b- defN 23-May-22 20:55 dscan_api_client/api/settings/settings_update.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/__init__.py
--rw-r--r--  2.0 unx     4651 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_create.py
--rw-r--r--  2.0 unx     2558 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_destroy.py
--rw-r--r--  2.0 unx     3694 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_list.py
--rw-r--r--  2.0 unx     5078 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_partial_update.py
--rw-r--r--  2.0 unx     3678 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_retrieve.py
--rw-r--r--  2.0 unx     4858 b- defN 23-May-22 20:55 dscan_api_client/api/subdomains/subdomains_update.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/tagschema/__init__.py
--rw-r--r--  2.0 unx     5400 b- defN 23-May-22 20:55 dscan_api_client/api/tagschema/field_schema_retrieve.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/__init__.py
--rw-r--r--  2.0 unx     4466 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_create.py
--rw-r--r--  2.0 unx     2553 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_destroy.py
--rw-r--r--  2.0 unx     3624 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_list.py
--rw-r--r--  2.0 unx     4883 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_partial_update.py
--rw-r--r--  2.0 unx     3608 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_retrieve.py
--rw-r--r--  2.0 unx     4673 b- defN 23-May-22 20:55 dscan_api_client/api/tasks/tasks_update.py
--rw-r--r--  2.0 unx     1027 b- defN 23-May-22 20:55 dscan_api_client/models/__init__.py
--rw-r--r--  2.0 unx     6120 b- defN 23-May-22 20:55 dscan_api_client/models/patched_program.py
--rw-r--r--  2.0 unx     7372 b- defN 23-May-22 20:55 dscan_api_client/models/patched_scan.py
--rw-r--r--  2.0 unx     5478 b- defN 23-May-22 20:55 dscan_api_client/models/patched_scanner.py
--rw-r--r--  2.0 unx     6411 b- defN 23-May-22 20:55 dscan_api_client/models/patched_subdomain.py
--rw-r--r--  2.0 unx     6075 b- defN 23-May-22 20:55 dscan_api_client/models/patched_task.py
--rw-r--r--  2.0 unx     4149 b- defN 23-May-22 20:55 dscan_api_client/models/program.py
--rw-r--r--  2.0 unx     2017 b- defN 23-May-22 20:55 dscan_api_client/models/program_subdomain_check.py
--rw-r--r--  2.0 unx     6021 b- defN 23-May-22 20:55 dscan_api_client/models/scan.py
--rw-r--r--  2.0 unx     4515 b- defN 23-May-22 20:55 dscan_api_client/models/scanner.py
--rw-r--r--  2.0 unx      161 b- defN 23-May-22 20:55 dscan_api_client/models/schema_retrieve_format.py
--rw-r--r--  2.0 unx     1223 b- defN 23-May-22 20:55 dscan_api_client/models/schema_retrieve_response_200.py
--rw-r--r--  2.0 unx     5052 b- defN 23-May-22 20:55 dscan_api_client/models/subdomain.py
--rw-r--r--  2.0 unx     4439 b- defN 23-May-22 20:55 dscan_api_client/models/subdomain_detail.py
--rw-r--r--  2.0 unx     3801 b- defN 23-May-22 20:55 dscan_api_client/models/subdomain_with_detail.py
--rw-r--r--  2.0 unx     4718 b- defN 23-May-22 20:55 dscan_api_client/models/task.py
--rw-r--r--  2.0 unx     1065 b- defN 23-May-22 20:55 dscan_api_client-1.0.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     4090 b- defN 23-May-22 20:55 dscan_api_client-1.0.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-22 20:55 dscan_api_client-1.0.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       17 b- defN 23-May-22 20:55 dscan_api_client-1.0.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6790 b- defN 23-May-22 20:55 dscan_api_client-1.0.0.dist-info/RECORD
-68 files, 229654 bytes uncompressed, 53685 bytes compressed:  76.6%
+Zip file size: 61819 bytes, number of entries: 68
+-rw-r--r--  2.0 unx      153 b- defN 23-May-25 21:10 dscan_api_client/__init__.py
+-rw-r--r--  2.0 unx     2817 b- defN 23-May-25 21:10 dscan_api_client/client.py
+-rw-r--r--  2.0 unx      470 b- defN 23-May-25 21:10 dscan_api_client/errors.py
+-rw-r--r--  2.0 unx       25 b- defN 23-May-25 21:10 dscan_api_client/py.typed
+-rw-r--r--  2.0 unx      993 b- defN 23-May-25 21:10 dscan_api_client/types.py
+-rw-r--r--  2.0 unx       47 b- defN 23-May-25 21:10 dscan_api_client/api/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/programs/__init__.py
+-rw-r--r--  2.0 unx     3873 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_create.py
+-rw-r--r--  2.0 unx     2556 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_destroy.py
+-rw-r--r--  2.0 unx     3666 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_list.py
+-rw-r--r--  2.0 unx     4198 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_partial_update.py
+-rw-r--r--  2.0 unx     3650 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_retrieve.py
+-rw-r--r--  2.0 unx     4128 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_search_list.py
+-rw-r--r--  2.0 unx     2967 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_subdomain_check_create.py
+-rw-r--r--  2.0 unx     5533 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_subdomain_get_details_list.py
+-rw-r--r--  2.0 unx     5393 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_subdomain_get_list.py
+-rw-r--r--  2.0 unx     4080 b- defN 23-May-25 21:10 dscan_api_client/api/programs/programs_update.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/scans/__init__.py
+-rw-r--r--  2.0 unx     3804 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_create.py
+-rw-r--r--  2.0 unx     2553 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_destroy.py
+-rw-r--r--  2.0 unx     3624 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_list.py
+-rw-r--r--  2.0 unx     4123 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_partial_update.py
+-rw-r--r--  2.0 unx     3608 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_retrieve.py
+-rw-r--r--  2.0 unx     4011 b- defN 23-May-25 21:10 dscan_api_client/api/scans/scans_update.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/settings/__init__.py
+-rw-r--r--  2.0 unx     3873 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_create.py
+-rw-r--r--  2.0 unx     2556 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_destroy.py
+-rw-r--r--  2.0 unx     3666 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_list.py
+-rw-r--r--  2.0 unx     4198 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_partial_update.py
+-rw-r--r--  2.0 unx     3650 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_retrieve.py
+-rw-r--r--  2.0 unx     4080 b- defN 23-May-25 21:10 dscan_api_client/api/settings/settings_update.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/__init__.py
+-rw-r--r--  2.0 unx     3919 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_create.py
+-rw-r--r--  2.0 unx     2558 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_destroy.py
+-rw-r--r--  2.0 unx     3694 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_list.py
+-rw-r--r--  2.0 unx     4248 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_partial_update.py
+-rw-r--r--  2.0 unx     3678 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_retrieve.py
+-rw-r--r--  2.0 unx     4126 b- defN 23-May-25 21:10 dscan_api_client/api/subdomains/subdomains_update.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/tagschema/__init__.py
+-rw-r--r--  2.0 unx     5400 b- defN 23-May-25 21:10 dscan_api_client/api/tagschema/field_schema_retrieve.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/__init__.py
+-rw-r--r--  2.0 unx     3804 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_create.py
+-rw-r--r--  2.0 unx     2553 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_destroy.py
+-rw-r--r--  2.0 unx     3624 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_list.py
+-rw-r--r--  2.0 unx     4123 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_partial_update.py
+-rw-r--r--  2.0 unx     3608 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_retrieve.py
+-rw-r--r--  2.0 unx     4011 b- defN 23-May-25 21:10 dscan_api_client/api/tasks/tasks_update.py
+-rw-r--r--  2.0 unx     1027 b- defN 23-May-25 21:10 dscan_api_client/models/__init__.py
+-rw-r--r--  2.0 unx     4083 b- defN 23-May-25 21:10 dscan_api_client/models/patched_program.py
+-rw-r--r--  2.0 unx     4808 b- defN 23-May-25 21:10 dscan_api_client/models/patched_scan.py
+-rw-r--r--  2.0 unx     3625 b- defN 23-May-25 21:10 dscan_api_client/models/patched_scanner.py
+-rw-r--r--  2.0 unx     4255 b- defN 23-May-25 21:10 dscan_api_client/models/patched_subdomain.py
+-rw-r--r--  2.0 unx     4050 b- defN 23-May-25 21:10 dscan_api_client/models/patched_task.py
+-rw-r--r--  2.0 unx     2709 b- defN 23-May-25 21:10 dscan_api_client/models/program.py
+-rw-r--r--  2.0 unx     1502 b- defN 23-May-25 21:10 dscan_api_client/models/program_subdomain_check.py
+-rw-r--r--  2.0 unx     3830 b- defN 23-May-25 21:10 dscan_api_client/models/scan.py
+-rw-r--r--  2.0 unx     2929 b- defN 23-May-25 21:10 dscan_api_client/models/scanner.py
+-rw-r--r--  2.0 unx      161 b- defN 23-May-25 21:10 dscan_api_client/models/schema_retrieve_format.py
+-rw-r--r--  2.0 unx     1223 b- defN 23-May-25 21:10 dscan_api_client/models/schema_retrieve_response_200.py
+-rw-r--r--  2.0 unx     3273 b- defN 23-May-25 21:10 dscan_api_client/models/subdomain.py
+-rw-r--r--  2.0 unx     4439 b- defN 23-May-25 21:10 dscan_api_client/models/subdomain_detail.py
+-rw-r--r--  2.0 unx     3801 b- defN 23-May-25 21:10 dscan_api_client/models/subdomain_with_detail.py
+-rw-r--r--  2.0 unx     3069 b- defN 23-May-25 21:10 dscan_api_client/models/task.py
+-rw-r--r--  2.0 unx     1065 b- defN 23-May-25 21:10 dscan_api_client-1.0.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4090 b- defN 23-May-25 21:10 dscan_api_client-1.0.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-25 21:10 dscan_api_client-1.0.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       17 b- defN 23-May-25 21:10 dscan_api_client-1.0.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6790 b- defN 23-May-25 21:10 dscan_api_client-1.0.1.dist-info/RECORD
+68 files, 198479 bytes uncompressed, 50633 bytes compressed:  74.5%
```

## zipnote {}

```diff
@@ -183,23 +183,23 @@
 
 Filename: dscan_api_client/models/subdomain_with_detail.py
 Comment: 
 
 Filename: dscan_api_client/models/task.py
 Comment: 
 
-Filename: dscan_api_client-1.0.0.dist-info/LICENSE
+Filename: dscan_api_client-1.0.1.dist-info/LICENSE
 Comment: 
 
-Filename: dscan_api_client-1.0.0.dist-info/METADATA
+Filename: dscan_api_client-1.0.1.dist-info/METADATA
 Comment: 
 
-Filename: dscan_api_client-1.0.0.dist-info/WHEEL
+Filename: dscan_api_client-1.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: dscan_api_client-1.0.0.dist-info/top_level.txt
+Filename: dscan_api_client-1.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: dscan_api_client-1.0.0.dist-info/RECORD
+Filename: dscan_api_client-1.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dscan_api_client/api/programs/programs_create.py

```diff
@@ -8,35 +8,31 @@
 from ...models.program import Program
 from ...types import Response
 
 
 def _get_kwargs(
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Dict[str, Any]:
     url = "{}/api/programs/".format(client.base_url)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Program]:
     if response.status_code == HTTPStatus.CREATED:
         response_201 = Program.from_dict(response.json())
 
@@ -55,128 +51,108 @@
         parsed=_parse_response(client=client, response=response),
     )
 
 
 def sync_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Response[Program]:
     """
     Args:
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
 
     return _build_response(client=client, response=response)
 
 
 def sync(
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Optional[Program]:
     """
     Args:
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return sync_detailed(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Response[Program]:
     """
     Args:
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Optional[Program]:
     """
     Args:
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return (
         await asyncio_detailed(
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/programs/programs_partial_update.py

```diff
@@ -10,35 +10,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedProgram,
-    multipart_data: PatchedProgram,
     json_body: PatchedProgram,
 ) -> Dict[str, Any]:
     url = "{}/api/programs/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "patch",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Program]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Program.from_dict(response.json())
 
@@ -58,37 +54,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedProgram,
-    multipart_data: PatchedProgram,
     json_body: PatchedProgram,
 ) -> Response[Program]:
     """
     Args:
         id (int):
-        multipart_data (PatchedProgram):
         json_body (PatchedProgram):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -96,101 +87,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedProgram,
-    multipart_data: PatchedProgram,
     json_body: PatchedProgram,
 ) -> Optional[Program]:
     """
     Args:
         id (int):
-        multipart_data (PatchedProgram):
         json_body (PatchedProgram):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedProgram,
-    multipart_data: PatchedProgram,
     json_body: PatchedProgram,
 ) -> Response[Program]:
     """
     Args:
         id (int):
-        multipart_data (PatchedProgram):
         json_body (PatchedProgram):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedProgram,
-    multipart_data: PatchedProgram,
     json_body: PatchedProgram,
 ) -> Optional[Program]:
     """
     Args:
         id (int):
-        multipart_data (PatchedProgram):
         json_body (PatchedProgram):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/programs/programs_subdomain_check_create.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: ProgramSubdomainCheck,
-    multipart_data: ProgramSubdomainCheck,
     json_body: ProgramSubdomainCheck,
 ) -> Dict[str, Any]:
     url = "{}/api/programs/{id}/subdomain/check/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Any]:
     if response.status_code == HTTPStatus.CREATED:
         return None
     if client.raise_on_unexpected_status:
@@ -55,37 +51,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: ProgramSubdomainCheck,
-    multipart_data: ProgramSubdomainCheck,
     json_body: ProgramSubdomainCheck,
 ) -> Response[Any]:
     """
     Args:
         id (int):
-        multipart_data (ProgramSubdomainCheck):
         json_body (ProgramSubdomainCheck):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Any]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -93,37 +84,32 @@
     return _build_response(client=client, response=response)
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: ProgramSubdomainCheck,
-    multipart_data: ProgramSubdomainCheck,
     json_body: ProgramSubdomainCheck,
 ) -> Response[Any]:
     """
     Args:
         id (int):
-        multipart_data (ProgramSubdomainCheck):
         json_body (ProgramSubdomainCheck):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Any]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
```

## dscan_api_client/api/programs/programs_update.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Dict[str, Any]:
     url = "{}/api/programs/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "put",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Program]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Program.from_dict(response.json())
 
@@ -57,37 +53,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Response[Program]:
     """
     Args:
         id (int):
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -95,101 +86,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Optional[Program]:
     """
     Args:
         id (int):
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Response[Program]:
     """
     Args:
         id (int):
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Program]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Program,
-    multipart_data: Program,
     json_body: Program,
 ) -> Optional[Program]:
     """
     Args:
         id (int):
-        multipart_data (Program):
         json_body (Program):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Program
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/scans/scans_create.py

```diff
@@ -8,35 +8,31 @@
 from ...models.scan import Scan
 from ...types import Response
 
 
 def _get_kwargs(
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Dict[str, Any]:
     url = "{}/api/scans/".format(client.base_url)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scan]:
     if response.status_code == HTTPStatus.CREATED:
         response_201 = Scan.from_dict(response.json())
 
@@ -55,128 +51,108 @@
         parsed=_parse_response(client=client, response=response),
     )
 
 
 def sync_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Response[Scan]:
     """
     Args:
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
 
     return _build_response(client=client, response=response)
 
 
 def sync(
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Optional[Scan]:
     """
     Args:
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return sync_detailed(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Response[Scan]:
     """
     Args:
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Optional[Scan]:
     """
     Args:
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return (
         await asyncio_detailed(
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/scans/scans_partial_update.py

```diff
@@ -10,35 +10,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScan,
-    multipart_data: PatchedScan,
     json_body: PatchedScan,
 ) -> Dict[str, Any]:
     url = "{}/api/scans/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "patch",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scan]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Scan.from_dict(response.json())
 
@@ -58,37 +54,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScan,
-    multipart_data: PatchedScan,
     json_body: PatchedScan,
 ) -> Response[Scan]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScan):
         json_body (PatchedScan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -96,101 +87,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScan,
-    multipart_data: PatchedScan,
     json_body: PatchedScan,
 ) -> Optional[Scan]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScan):
         json_body (PatchedScan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScan,
-    multipart_data: PatchedScan,
     json_body: PatchedScan,
 ) -> Response[Scan]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScan):
         json_body (PatchedScan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScan,
-    multipart_data: PatchedScan,
     json_body: PatchedScan,
 ) -> Optional[Scan]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScan):
         json_body (PatchedScan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/scans/scans_update.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Dict[str, Any]:
     url = "{}/api/scans/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "put",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scan]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Scan.from_dict(response.json())
 
@@ -57,37 +53,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Response[Scan]:
     """
     Args:
         id (int):
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -95,101 +86,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Optional[Scan]:
     """
     Args:
         id (int):
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Response[Scan]:
     """
     Args:
         id (int):
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scan]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scan,
-    multipart_data: Scan,
     json_body: Scan,
 ) -> Optional[Scan]:
     """
     Args:
         id (int):
-        multipart_data (Scan):
         json_body (Scan):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scan
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/settings/settings_create.py

```diff
@@ -8,35 +8,31 @@
 from ...models.scanner import Scanner
 from ...types import Response
 
 
 def _get_kwargs(
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Dict[str, Any]:
     url = "{}/api/settings/".format(client.base_url)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scanner]:
     if response.status_code == HTTPStatus.CREATED:
         response_201 = Scanner.from_dict(response.json())
 
@@ -55,128 +51,108 @@
         parsed=_parse_response(client=client, response=response),
     )
 
 
 def sync_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Response[Scanner]:
     """
     Args:
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
 
     return _build_response(client=client, response=response)
 
 
 def sync(
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Optional[Scanner]:
     """
     Args:
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return sync_detailed(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Response[Scanner]:
     """
     Args:
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Optional[Scanner]:
     """
     Args:
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return (
         await asyncio_detailed(
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/settings/settings_partial_update.py

```diff
@@ -10,35 +10,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScanner,
-    multipart_data: PatchedScanner,
     json_body: PatchedScanner,
 ) -> Dict[str, Any]:
     url = "{}/api/settings/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "patch",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scanner]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Scanner.from_dict(response.json())
 
@@ -58,37 +54,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScanner,
-    multipart_data: PatchedScanner,
     json_body: PatchedScanner,
 ) -> Response[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScanner):
         json_body (PatchedScanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -96,101 +87,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScanner,
-    multipart_data: PatchedScanner,
     json_body: PatchedScanner,
 ) -> Optional[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScanner):
         json_body (PatchedScanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScanner,
-    multipart_data: PatchedScanner,
     json_body: PatchedScanner,
 ) -> Response[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScanner):
         json_body (PatchedScanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedScanner,
-    multipart_data: PatchedScanner,
     json_body: PatchedScanner,
 ) -> Optional[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (PatchedScanner):
         json_body (PatchedScanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/settings/settings_update.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Dict[str, Any]:
     url = "{}/api/settings/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "put",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Scanner]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Scanner.from_dict(response.json())
 
@@ -57,37 +53,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Response[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -95,101 +86,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Optional[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Response[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Scanner]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Scanner,
-    multipart_data: Scanner,
     json_body: Scanner,
 ) -> Optional[Scanner]:
     """
     Args:
         id (int):
-        multipart_data (Scanner):
         json_body (Scanner):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Scanner
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/subdomains/subdomains_create.py

```diff
@@ -8,35 +8,31 @@
 from ...models.subdomain import Subdomain
 from ...types import Response
 
 
 def _get_kwargs(
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Dict[str, Any]:
     url = "{}/api/subdomains/".format(client.base_url)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Subdomain]:
     if response.status_code == HTTPStatus.CREATED:
         response_201 = Subdomain.from_dict(response.json())
 
@@ -55,128 +51,108 @@
         parsed=_parse_response(client=client, response=response),
     )
 
 
 def sync_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Response[Subdomain]:
     """
     Args:
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
 
     return _build_response(client=client, response=response)
 
 
 def sync(
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return sync_detailed(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Response[Subdomain]:
     """
     Args:
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return (
         await asyncio_detailed(
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/subdomains/subdomains_partial_update.py

```diff
@@ -10,35 +10,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedSubdomain,
-    multipart_data: PatchedSubdomain,
     json_body: PatchedSubdomain,
 ) -> Dict[str, Any]:
     url = "{}/api/subdomains/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "patch",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Subdomain]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Subdomain.from_dict(response.json())
 
@@ -58,37 +54,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedSubdomain,
-    multipart_data: PatchedSubdomain,
     json_body: PatchedSubdomain,
 ) -> Response[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (PatchedSubdomain):
         json_body (PatchedSubdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -96,101 +87,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedSubdomain,
-    multipart_data: PatchedSubdomain,
     json_body: PatchedSubdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (PatchedSubdomain):
         json_body (PatchedSubdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedSubdomain,
-    multipart_data: PatchedSubdomain,
     json_body: PatchedSubdomain,
 ) -> Response[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (PatchedSubdomain):
         json_body (PatchedSubdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedSubdomain,
-    multipart_data: PatchedSubdomain,
     json_body: PatchedSubdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (PatchedSubdomain):
         json_body (PatchedSubdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/subdomains/subdomains_update.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Dict[str, Any]:
     url = "{}/api/subdomains/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "put",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Subdomain]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Subdomain.from_dict(response.json())
 
@@ -57,37 +53,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Response[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -95,101 +86,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Response[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Subdomain]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Subdomain,
-    multipart_data: Subdomain,
     json_body: Subdomain,
 ) -> Optional[Subdomain]:
     """
     Args:
         id (int):
-        multipart_data (Subdomain):
         json_body (Subdomain):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Subdomain
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/tasks/tasks_create.py

```diff
@@ -8,35 +8,31 @@
 from ...models.task import Task
 from ...types import Response
 
 
 def _get_kwargs(
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Dict[str, Any]:
     url = "{}/api/tasks/".format(client.base_url)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "post",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Task]:
     if response.status_code == HTTPStatus.CREATED:
         response_201 = Task.from_dict(response.json())
 
@@ -55,128 +51,108 @@
         parsed=_parse_response(client=client, response=response),
     )
 
 
 def sync_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Response[Task]:
     """
     Args:
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
 
     return _build_response(client=client, response=response)
 
 
 def sync(
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Optional[Task]:
     """
     Args:
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return sync_detailed(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Response[Task]:
     """
     Args:
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Optional[Task]:
     """
     Args:
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return (
         await asyncio_detailed(
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/tasks/tasks_partial_update.py

```diff
@@ -10,35 +10,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedTask,
-    multipart_data: PatchedTask,
     json_body: PatchedTask,
 ) -> Dict[str, Any]:
     url = "{}/api/tasks/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "patch",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Task]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Task.from_dict(response.json())
 
@@ -58,37 +54,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedTask,
-    multipart_data: PatchedTask,
     json_body: PatchedTask,
 ) -> Response[Task]:
     """
     Args:
         id (int):
-        multipart_data (PatchedTask):
         json_body (PatchedTask):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -96,101 +87,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedTask,
-    multipart_data: PatchedTask,
     json_body: PatchedTask,
 ) -> Optional[Task]:
     """
     Args:
         id (int):
-        multipart_data (PatchedTask):
         json_body (PatchedTask):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedTask,
-    multipart_data: PatchedTask,
     json_body: PatchedTask,
 ) -> Response[Task]:
     """
     Args:
         id (int):
-        multipart_data (PatchedTask):
         json_body (PatchedTask):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: PatchedTask,
-    multipart_data: PatchedTask,
     json_body: PatchedTask,
 ) -> Optional[Task]:
     """
     Args:
         id (int):
-        multipart_data (PatchedTask):
         json_body (PatchedTask):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/api/tasks/tasks_update.py

```diff
@@ -9,35 +9,31 @@
 from ...types import Response
 
 
 def _get_kwargs(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Dict[str, Any]:
     url = "{}/api/tasks/{id}/".format(client.base_url, id=id)
 
     headers: Dict[str, str] = client.get_headers()
     cookies: Dict[str, Any] = client.get_cookies()
 
-    json_body.to_dict()
-
-    multipart_data.to_multipart()
+    json_json_body = json_body.to_dict()
 
     return {
         "method": "put",
         "url": url,
         "headers": headers,
         "cookies": cookies,
         "timeout": client.get_timeout(),
         "follow_redirects": client.follow_redirects,
-        "data": form_data.to_dict(),
+        "json": json_json_body,
     }
 
 
 def _parse_response(*, client: Client, response: httpx.Response) -> Optional[Task]:
     if response.status_code == HTTPStatus.OK:
         response_200 = Task.from_dict(response.json())
 
@@ -57,37 +53,32 @@
     )
 
 
 def sync_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Response[Task]:
     """
     Args:
         id (int):
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     response = httpx.request(
         verify=client.verify_ssl,
         **kwargs,
     )
@@ -95,101 +86,86 @@
     return _build_response(client=client, response=response)
 
 
 def sync(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Optional[Task]:
     """
     Args:
         id (int):
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return sync_detailed(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     ).parsed
 
 
 async def asyncio_detailed(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Response[Task]:
     """
     Args:
         id (int):
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Response[Task]
     """
 
     kwargs = _get_kwargs(
         id=id,
         client=client,
-        form_data=form_data,
-        multipart_data=multipart_data,
         json_body=json_body,
     )
 
     async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
         response = await _client.request(**kwargs)
 
     return _build_response(client=client, response=response)
 
 
 async def asyncio(
     id: int,
     *,
     client: AuthenticatedClient,
-    form_data: Task,
-    multipart_data: Task,
     json_body: Task,
 ) -> Optional[Task]:
     """
     Args:
         id (int):
-        multipart_data (Task):
         json_body (Task):
 
     Raises:
         errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
         httpx.TimeoutException: If the request takes longer than Client.timeout.
 
     Returns:
         Task
     """
 
     return (
         await asyncio_detailed(
             id=id,
             client=client,
-            form_data=form_data,
-            multipart_data=multipart_data,
             json_body=json_body,
         )
     ).parsed
```

## dscan_api_client/models/patched_program.py

```diff
@@ -1,10 +1,9 @@
 import datetime
-import json
-from typing import Any, Dict, List, Tuple, Type, TypeVar, Union, cast
+from typing import Any, Dict, List, Type, TypeVar, Union, cast
 
 import attr
 from dateutil.parser import isoparse
 
 from ..types import UNSET, Unset
 
 T = TypeVar("T", bound="PatchedProgram")
@@ -57,57 +56,14 @@
         field_dict.update({})
         if id is not UNSET:
             field_dict["id"] = id
         if subdomain is not UNSET:
             field_dict["subdomain"] = subdomain
         if name is not UNSET:
             field_dict["name"] = name
-        if url is not UNSET:
-            field_dict["url"] = url
-        if bounty is not UNSET:
-            field_dict["bounty"] = bounty
-        if enabled is not UNSET:
-            field_dict["enabled"] = enabled
-        if created_at is not UNSET:
-            field_dict["created_at"] = created_at
-        if updated_at is not UNSET:
-            field_dict["updated_at"] = updated_at
-
-        return field_dict
-
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        subdomain: Union[Unset, Tuple[None, bytes, str]] = UNSET
-        if not isinstance(self.subdomain, Unset):
-            _temp_subdomain = self.subdomain
-            subdomain = (None, json.dumps(_temp_subdomain).encode(), "application/json")
-
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        url = self.url if isinstance(self.url, Unset) else (None, str(self.url).encode(), "text/plain")
-        bounty = self.bounty if isinstance(self.bounty, Unset) else (None, str(self.bounty).encode(), "text/plain")
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        created_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.created_at, Unset):
-            created_at = self.created_at.isoformat().encode()
-
-        updated_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.updated_at, Unset):
-            updated_at = self.updated_at.isoformat().encode()
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update({})
-        if id is not UNSET:
-            field_dict["id"] = id
-        if subdomain is not UNSET:
-            field_dict["subdomain"] = subdomain
-        if name is not UNSET:
-            field_dict["name"] = name
         if url is not UNSET:
             field_dict["url"] = url
         if bounty is not UNSET:
             field_dict["bounty"] = bounty
         if enabled is not UNSET:
             field_dict["enabled"] = enabled
         if created_at is not UNSET:
```

## dscan_api_client/models/patched_scan.py

```diff
@@ -82,67 +82,14 @@
         if n_type is not UNSET:
             field_dict["n_type"] = n_type
         if program is not UNSET:
             field_dict["program"] = program
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        issues_found = (
-            self.issues_found
-            if isinstance(self.issues_found, Unset)
-            else (None, str(self.issues_found).encode(), "text/plain")
-        )
-        comment = self.comment if isinstance(self.comment, Unset) else (None, str(self.comment).encode(), "text/plain")
-        created_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.created_at, Unset):
-            created_at = self.created_at.isoformat().encode()
-
-        updated_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.updated_at, Unset):
-            updated_at = self.updated_at.isoformat().encode()
-
-        reason = self.reason if isinstance(self.reason, Unset) else (None, str(self.reason).encode(), "text/plain")
-        s_type = self.s_type if isinstance(self.s_type, Unset) else (None, str(self.s_type).encode(), "text/plain")
-        n_type = self.n_type if isinstance(self.n_type, Unset) else (None, str(self.n_type).encode(), "text/plain")
-        program = self.program if isinstance(self.program, Unset) else (None, str(self.program).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update({})
-        if id is not UNSET:
-            field_dict["id"] = id
-        if name is not UNSET:
-            field_dict["name"] = name
-        if status is not UNSET:
-            field_dict["status"] = status
-        if issues_found is not UNSET:
-            field_dict["issues_found"] = issues_found
-        if comment is not UNSET:
-            field_dict["comment"] = comment
-        if created_at is not UNSET:
-            field_dict["created_at"] = created_at
-        if updated_at is not UNSET:
-            field_dict["updated_at"] = updated_at
-        if reason is not UNSET:
-            field_dict["reason"] = reason
-        if s_type is not UNSET:
-            field_dict["s_type"] = s_type
-        if n_type is not UNSET:
-            field_dict["n_type"] = n_type
-        if program is not UNSET:
-            field_dict["program"] = program
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id", UNSET)
 
         name = d.pop("name", UNSET)
```

## dscan_api_client/models/patched_scanner.py

```diff
@@ -64,51 +64,14 @@
         if updated_at is not UNSET:
             field_dict["updated_at"] = updated_at
         if version is not UNSET:
             field_dict["version"] = version
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        s_type = self.s_type if isinstance(self.s_type, Unset) else (None, str(self.s_type).encode(), "text/plain")
-        config = self.config if isinstance(self.config, Unset) else (None, str(self.config).encode(), "text/plain")
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        comment = self.comment if isinstance(self.comment, Unset) else (None, str(self.comment).encode(), "text/plain")
-        updated_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.updated_at, Unset):
-            updated_at = self.updated_at.isoformat().encode()
-
-        version = self.version if isinstance(self.version, Unset) else (None, str(self.version).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update({})
-        if id is not UNSET:
-            field_dict["id"] = id
-        if name is not UNSET:
-            field_dict["name"] = name
-        if s_type is not UNSET:
-            field_dict["s_type"] = s_type
-        if config is not UNSET:
-            field_dict["config"] = config
-        if enabled is not UNSET:
-            field_dict["enabled"] = enabled
-        if comment is not UNSET:
-            field_dict["comment"] = comment
-        if updated_at is not UNSET:
-            field_dict["updated_at"] = updated_at
-        if version is not UNSET:
-            field_dict["version"] = version
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id", UNSET)
 
         name = d.pop("name", UNSET)
```

## dscan_api_client/models/patched_subdomain.py

```diff
@@ -72,61 +72,14 @@
         if program is not UNSET:
             field_dict["program"] = program
         if scan is not UNSET:
             field_dict["scan"] = scan
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        is_primary = (
-            self.is_primary
-            if isinstance(self.is_primary, Unset)
-            else (None, str(self.is_primary).encode(), "text/plain")
-        )
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        created_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.created_at, Unset):
-            created_at = self.created_at.isoformat().encode()
-
-        updated_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.updated_at, Unset):
-            updated_at = self.updated_at.isoformat().encode()
-
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        program = self.program if isinstance(self.program, Unset) else (None, str(self.program).encode(), "text/plain")
-        scan = self.scan if isinstance(self.scan, Unset) else (None, str(self.scan).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update({})
-        if id is not UNSET:
-            field_dict["id"] = id
-        if name is not UNSET:
-            field_dict["name"] = name
-        if is_primary is not UNSET:
-            field_dict["is_primary"] = is_primary
-        if status is not UNSET:
-            field_dict["status"] = status
-        if created_at is not UNSET:
-            field_dict["created_at"] = created_at
-        if updated_at is not UNSET:
-            field_dict["updated_at"] = updated_at
-        if enabled is not UNSET:
-            field_dict["enabled"] = enabled
-        if program is not UNSET:
-            field_dict["program"] = program
-        if scan is not UNSET:
-            field_dict["scan"] = scan
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id", UNSET)
 
         name = d.pop("name", UNSET)
```

## dscan_api_client/models/patched_task.py

```diff
@@ -67,60 +67,14 @@
         if task_name is not UNSET:
             field_dict["task_name"] = task_name
         if scan is not UNSET:
             field_dict["scan"] = scan
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        task_id = self.task_id if isinstance(self.task_id, Unset) else (None, str(self.task_id).encode(), "text/plain")
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        is_finished = (
-            self.is_finished
-            if isinstance(self.is_finished, Unset)
-            else (None, str(self.is_finished).encode(), "text/plain")
-        )
-        created_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.created_at, Unset):
-            created_at = self.created_at.isoformat().encode()
-
-        updated_at: Union[Unset, bytes] = UNSET
-        if not isinstance(self.updated_at, Unset):
-            updated_at = self.updated_at.isoformat().encode()
-
-        task_name = (
-            self.task_name if isinstance(self.task_name, Unset) else (None, str(self.task_name).encode(), "text/plain")
-        )
-        scan = self.scan if isinstance(self.scan, Unset) else (None, str(self.scan).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update({})
-        if id is not UNSET:
-            field_dict["id"] = id
-        if task_id is not UNSET:
-            field_dict["task_id"] = task_id
-        if status is not UNSET:
-            field_dict["status"] = status
-        if is_finished is not UNSET:
-            field_dict["is_finished"] = is_finished
-        if created_at is not UNSET:
-            field_dict["created_at"] = created_at
-        if updated_at is not UNSET:
-            field_dict["updated_at"] = updated_at
-        if task_name is not UNSET:
-            field_dict["task_name"] = task_name
-        if scan is not UNSET:
-            field_dict["scan"] = scan
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id", UNSET)
 
         task_id = d.pop("task_id", UNSET)
```

## dscan_api_client/models/program.py

```diff
@@ -1,16 +1,13 @@
 import datetime
-import json
 from typing import Any, Dict, List, Type, TypeVar, cast
 
 import attr
 from dateutil.parser import isoparse
 
-from ..types import Unset
-
 T = TypeVar("T", bound="Program")
 
 
 @attr.s(auto_attribs=True)
 class Program:
     """
     Attributes:
@@ -51,46 +48,14 @@
         field_dict.update(
             {
                 "id": id,
                 "subdomain": subdomain,
                 "name": name,
                 "url": url,
                 "bounty": bounty,
-                "enabled": enabled,
-                "created_at": created_at,
-                "updated_at": updated_at,
-            }
-        )
-
-        return field_dict
-
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        _temp_subdomain = self.subdomain
-        subdomain = (None, json.dumps(_temp_subdomain).encode(), "application/json")
-
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        url = self.url if isinstance(self.url, Unset) else (None, str(self.url).encode(), "text/plain")
-        bounty = self.bounty if isinstance(self.bounty, Unset) else (None, str(self.bounty).encode(), "text/plain")
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        created_at = self.created_at.isoformat().encode()
-
-        updated_at = self.updated_at.isoformat().encode()
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "id": id,
-                "subdomain": subdomain,
-                "name": name,
-                "url": url,
-                "bounty": bounty,
                 "enabled": enabled,
                 "created_at": created_at,
                 "updated_at": updated_at,
             }
         )
 
         return field_dict
```

## dscan_api_client/models/program_subdomain_check.py

```diff
@@ -1,8 +1,7 @@
-import json
 from typing import Any, Dict, List, Type, TypeVar, cast
 
 import attr
 
 T = TypeVar("T", bound="ProgramSubdomainCheck")
 
 
@@ -24,30 +23,14 @@
         field_dict.update(
             {
                 "subdomains": subdomains,
             }
         )
 
         return field_dict
-
-    def to_multipart(self) -> Dict[str, Any]:
-        _temp_subdomains = self.subdomains
-        subdomains = (None, json.dumps(_temp_subdomains).encode(), "application/json")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "subdomains": subdomains,
-            }
-        )
-
-        return field_dict
 
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         subdomains = cast(List[Any], d.pop("subdomains"))
 
         program_subdomain_check = cls(
```

## dscan_api_client/models/scan.py

```diff
@@ -76,61 +76,14 @@
         if n_type is not UNSET:
             field_dict["n_type"] = n_type
         if program is not UNSET:
             field_dict["program"] = program
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        created_at = self.created_at.isoformat().encode()
-
-        updated_at = self.updated_at.isoformat().encode()
-
-        issues_found = (
-            self.issues_found
-            if isinstance(self.issues_found, Unset)
-            else (None, str(self.issues_found).encode(), "text/plain")
-        )
-        comment = self.comment if isinstance(self.comment, Unset) else (None, str(self.comment).encode(), "text/plain")
-        reason = self.reason if isinstance(self.reason, Unset) else (None, str(self.reason).encode(), "text/plain")
-        s_type = self.s_type if isinstance(self.s_type, Unset) else (None, str(self.s_type).encode(), "text/plain")
-        n_type = self.n_type if isinstance(self.n_type, Unset) else (None, str(self.n_type).encode(), "text/plain")
-        program = self.program if isinstance(self.program, Unset) else (None, str(self.program).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "id": id,
-                "name": name,
-                "status": status,
-                "created_at": created_at,
-                "updated_at": updated_at,
-            }
-        )
-        if issues_found is not UNSET:
-            field_dict["issues_found"] = issues_found
-        if comment is not UNSET:
-            field_dict["comment"] = comment
-        if reason is not UNSET:
-            field_dict["reason"] = reason
-        if s_type is not UNSET:
-            field_dict["s_type"] = s_type
-        if n_type is not UNSET:
-            field_dict["n_type"] = n_type
-        if program is not UNSET:
-            field_dict["program"] = program
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id")
 
         name = d.pop("name")
```

## dscan_api_client/models/scanner.py

```diff
@@ -60,47 +60,14 @@
         if comment is not UNSET:
             field_dict["comment"] = comment
         if version is not UNSET:
             field_dict["version"] = version
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        s_type = self.s_type if isinstance(self.s_type, Unset) else (None, str(self.s_type).encode(), "text/plain")
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        updated_at = self.updated_at.isoformat().encode()
-
-        config = self.config if isinstance(self.config, Unset) else (None, str(self.config).encode(), "text/plain")
-        comment = self.comment if isinstance(self.comment, Unset) else (None, str(self.comment).encode(), "text/plain")
-        version = self.version if isinstance(self.version, Unset) else (None, str(self.version).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "id": id,
-                "name": name,
-                "s_type": s_type,
-                "enabled": enabled,
-                "updated_at": updated_at,
-            }
-        )
-        if config is not UNSET:
-            field_dict["config"] = config
-        if comment is not UNSET:
-            field_dict["comment"] = comment
-        if version is not UNSET:
-            field_dict["version"] = version
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id")
 
         name = d.pop("name")
```

## dscan_api_client/models/subdomain.py

```diff
@@ -66,55 +66,14 @@
         if program is not UNSET:
             field_dict["program"] = program
         if scan is not UNSET:
             field_dict["scan"] = scan
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")
-        is_primary = (
-            self.is_primary
-            if isinstance(self.is_primary, Unset)
-            else (None, str(self.is_primary).encode(), "text/plain")
-        )
-        created_at = self.created_at.isoformat().encode()
-
-        updated_at = self.updated_at.isoformat().encode()
-
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        enabled = self.enabled if isinstance(self.enabled, Unset) else (None, str(self.enabled).encode(), "text/plain")
-        program = self.program if isinstance(self.program, Unset) else (None, str(self.program).encode(), "text/plain")
-        scan = self.scan if isinstance(self.scan, Unset) else (None, str(self.scan).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "id": id,
-                "name": name,
-                "is_primary": is_primary,
-                "created_at": created_at,
-                "updated_at": updated_at,
-            }
-        )
-        if status is not UNSET:
-            field_dict["status"] = status
-        if enabled is not UNSET:
-            field_dict["enabled"] = enabled
-        if program is not UNSET:
-            field_dict["program"] = program
-        if scan is not UNSET:
-            field_dict["scan"] = scan
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id")
 
         name = d.pop("name")
```

## dscan_api_client/models/task.py

```diff
@@ -61,54 +61,14 @@
         if task_name is not UNSET:
             field_dict["task_name"] = task_name
         if scan is not UNSET:
             field_dict["scan"] = scan
 
         return field_dict
 
-    def to_multipart(self) -> Dict[str, Any]:
-        id = self.id if isinstance(self.id, Unset) else (None, str(self.id).encode(), "text/plain")
-        task_id = self.task_id if isinstance(self.task_id, Unset) else (None, str(self.task_id).encode(), "text/plain")
-        status = self.status if isinstance(self.status, Unset) else (None, str(self.status).encode(), "text/plain")
-        created_at = self.created_at.isoformat().encode()
-
-        updated_at = self.updated_at.isoformat().encode()
-
-        is_finished = (
-            self.is_finished
-            if isinstance(self.is_finished, Unset)
-            else (None, str(self.is_finished).encode(), "text/plain")
-        )
-        task_name = (
-            self.task_name if isinstance(self.task_name, Unset) else (None, str(self.task_name).encode(), "text/plain")
-        )
-        scan = self.scan if isinstance(self.scan, Unset) else (None, str(self.scan).encode(), "text/plain")
-
-        field_dict: Dict[str, Any] = {}
-        field_dict.update(
-            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
-        )
-        field_dict.update(
-            {
-                "id": id,
-                "task_id": task_id,
-                "status": status,
-                "created_at": created_at,
-                "updated_at": updated_at,
-            }
-        )
-        if is_finished is not UNSET:
-            field_dict["is_finished"] = is_finished
-        if task_name is not UNSET:
-            field_dict["task_name"] = task_name
-        if scan is not UNSET:
-            field_dict["scan"] = scan
-
-        return field_dict
-
     @classmethod
     def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
         d = src_dict.copy()
         id = d.pop("id")
 
         task_id = d.pop("task_id")
```

## Comparing `dscan_api_client-1.0.0.dist-info/LICENSE` & `dscan_api_client-1.0.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dscan_api_client-1.0.0.dist-info/METADATA` & `dscan_api_client-1.0.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dscan-api-client
-Version: 1.0.0
+Version: 1.0.1
 Summary: A client library for accessing Dscan API
 Requires-Python: >=3.8, <4
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: httpx (<0.25.0,>=0.15.0)
 Requires-Dist: attrs (>=21.3.0)
 Requires-Dist: python-dateutil (<3,>=2.8.0)
```

## Comparing `dscan_api_client-1.0.0.dist-info/RECORD` & `dscan_api_client-1.0.1.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,68 @@
 dscan_api_client/__init__.py,sha256=IY_RWYXPTw-sPo1IYN3ffzOzSNxWus8Dji2ENO7Ohjg,153
 dscan_api_client/client.py,sha256=G6BpJg9j7-JsrAUGddYwkzeWRYickBjPdcVgXoPzxuE,2817
 dscan_api_client/errors.py,sha256=8mXSxdfSGzxT82srdhYbR0fHfgenxJXaUtMkaGgb6iU,470
 dscan_api_client/py.typed,sha256=8ZJUsxZiuOy1oJeVhsTWQhTG_6pTVHVXk5hJL79ebTk,25
 dscan_api_client/types.py,sha256=4xaUIOliefW-5jz_p-JT2LO7-V0wKWaniHGtjPBQfvQ,993
 dscan_api_client/api/__init__.py,sha256=87ApBzKyGb5zsgTMOkQXDqsLZCmaSFoJMwbGzCDQZMw,47
 dscan_api_client/api/programs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dscan_api_client/api/programs/programs_create.py,sha256=vmp9MqtImvGMclzSPycgz658gqxNtj-GIU9XS3RKCvU,4577
+dscan_api_client/api/programs/programs_create.py,sha256=0QOQFSJaAW63O_0h5VHVIQN_UY2TAEMmMa9T5-Dl2Ao,3873
 dscan_api_client/api/programs/programs_destroy.py,sha256=p1etYIxhOS69nDPNIdvFBTWGndmdTS1Yk13ujjxrshI,2556
 dscan_api_client/api/programs/programs_list.py,sha256=ak49MX8Ujea931-aow6XAmt_9ttjycEASeD0znLJ6sU,3666
-dscan_api_client/api/programs/programs_partial_update.py,sha256=EOU9NfX3jNw-EziFfey8B1LEwq3H7NHDlrfMEgD5ArE,5000
+dscan_api_client/api/programs/programs_partial_update.py,sha256=c21TWE9U51i4zy--Xf8598NsdkAbYF-pi21FJwjj-4o,4198
 dscan_api_client/api/programs/programs_retrieve.py,sha256=yJIGK-_dF3PgKUsAdAi5V78pCMzIGTe4aI_S47a4KtI,3650
 dscan_api_client/api/programs/programs_search_list.py,sha256=5ki7FlRYWiS7PzvEF7ym2zIiKplnuPsgwHPagCmU2Kg,4128
-dscan_api_client/api/programs/programs_subdomain_check_create.py,sha256=87J8uv_-5Vi_p7Prj7stmbAd1uVCYo1RkOx8meVfEro,3465
+dscan_api_client/api/programs/programs_subdomain_check_create.py,sha256=8xxg6S_4oEEKBa-Sqr5vpkgjnqB8OHk-CKjABpF68TM,2967
 dscan_api_client/api/programs/programs_subdomain_get_details_list.py,sha256=NV34EG7raUxpTC-2n4PWzgOfV3nUq02LETiwRremjDs,5533
 dscan_api_client/api/programs/programs_subdomain_get_list.py,sha256=P1JAkWwkmpxgAUvCnja0QOEjRkXQ5hRq4HQYNJRQb3s,5393
-dscan_api_client/api/programs/programs_update.py,sha256=_KmVkHRopZEXEu1LS1WHIDtpA0Gs7PGUtEJ-6YQXUgs,4784
+dscan_api_client/api/programs/programs_update.py,sha256=bYWbPyAguxVty0Ed2EczS12LA91_x6oWQ7WvjSK0H-M,4080
 dscan_api_client/api/scans/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dscan_api_client/api/scans/scans_create.py,sha256=rBhNkNDZPkqgaw6OOjQ9oxNqi5pgYgrjHA6rKjCu4mM,4466
+dscan_api_client/api/scans/scans_create.py,sha256=N7QIDBMKLwCf-KEc84qrfQKitjBQ0TOCLC3cy0N4bWk,3804
 dscan_api_client/api/scans/scans_destroy.py,sha256=KEl_3c8qachUEmG5FKOobrrFkCZsx6vTXCI8CfqLrU0,2553
 dscan_api_client/api/scans/scans_list.py,sha256=cXJdRG9QG5O-mp0YujtM0NyBheiWzFf7ouVWcCpx2tI,3624
-dscan_api_client/api/scans/scans_partial_update.py,sha256=FI_veI9z56oot31sN_KeRNRB-CHaW9xfEFqk0EI0iPM,4883
+dscan_api_client/api/scans/scans_partial_update.py,sha256=uIdPxxQN7C9zvxEdXu--BnYZVgAzLHVQ1nakAAUpmyE,4123
 dscan_api_client/api/scans/scans_retrieve.py,sha256=Hplzc57GKT9z-mHY4E_Cp79XhynWqX0b2QOI17KIRK4,3608
-dscan_api_client/api/scans/scans_update.py,sha256=PeCm1glglJ29vzPMfqJxXD6KHAqZAsISfucg90Nf5EQ,4673
+dscan_api_client/api/scans/scans_update.py,sha256=ZrI0tm1CDH3IxACJ-Cgm5qORz-sObcrCpirOmlJH6ZM,4011
 dscan_api_client/api/settings/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dscan_api_client/api/settings/settings_create.py,sha256=vh_6qCPdtF7HIQNjRiF3ntDhgwj7AG2VtYwvSIctJcY,4577
+dscan_api_client/api/settings/settings_create.py,sha256=vkAV0cPcFMy-dHlxHgH45743IZGtSByVS27oixmjJcU,3873
 dscan_api_client/api/settings/settings_destroy.py,sha256=QkMNldL7Na-JQFDkumUwhF46eGKfVX6VZHG508sJ6Fg,2556
 dscan_api_client/api/settings/settings_list.py,sha256=jrLW3t8QI3fwY4Yw7dQVw-NM8siZQbpBW8eiNDUkU2Y,3666
-dscan_api_client/api/settings/settings_partial_update.py,sha256=LnCKl2vmSxhKXn0G0t9Ycl0E8txj4Kha4M_gUFs0S08,5000
+dscan_api_client/api/settings/settings_partial_update.py,sha256=hAEyDiaIFZgwQuzk2D-W_YVk0vjq3eZBNrj8esDjdGI,4198
 dscan_api_client/api/settings/settings_retrieve.py,sha256=rqP2eqSFpbw3kOZ8NoF1ztxR7dPTGPwzvADmv_PXB8M,3650
-dscan_api_client/api/settings/settings_update.py,sha256=Gx1HyOaaJ1RJDUALq4j8rJVm8nH-6FmTCwKfrTDD6Lc,4784
+dscan_api_client/api/settings/settings_update.py,sha256=73YZA3LgwpIwVuTg4tjpp-zjn8qCmeXN_IB6lTT5vhE,4080
 dscan_api_client/api/subdomains/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dscan_api_client/api/subdomains/subdomains_create.py,sha256=pWlBlIBLm62t-POuHW6X9Ic0ClxRm8a3o_E-i-qQfoo,4651
+dscan_api_client/api/subdomains/subdomains_create.py,sha256=xXgJqwjRSKEkS-K7PTZlUHgQnz6f1MXLwFgu3YCDVR4,3919
 dscan_api_client/api/subdomains/subdomains_destroy.py,sha256=i59Joo6HcmrQwAAUdRFr23b4V0UptqnwLRydZP_BmR4,2558
 dscan_api_client/api/subdomains/subdomains_list.py,sha256=-oiyUa5JBaBqevPZHkcspqfaFH2QZ1YgQUe8yvxywwc,3694
-dscan_api_client/api/subdomains/subdomains_partial_update.py,sha256=-XJdDsw3AY_7LrfB8XZtBp2fXmqW-hzFot1B8KNBmag,5078
+dscan_api_client/api/subdomains/subdomains_partial_update.py,sha256=d9-wdiaZWkVGvJzqUyKyjXxkZ6o-b6rPlbJhPIAzeAs,4248
 dscan_api_client/api/subdomains/subdomains_retrieve.py,sha256=DZ8AnU_AccdmtCHgl952US3MlPH53gLGP6rDOyY15Mo,3678
-dscan_api_client/api/subdomains/subdomains_update.py,sha256=rxFDBK50PD0WCPA39kBd-E_tniHc6tpxBTv2_U8gPnI,4858
+dscan_api_client/api/subdomains/subdomains_update.py,sha256=N60NdCaRVfOuVf8fgq8sltMWnm65_ahAP4yHkyzP_Jk,4126
 dscan_api_client/api/tagschema/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dscan_api_client/api/tagschema/field_schema_retrieve.py,sha256=2GxrScUkdnZIR1i0vyxtgkKDnvi3OeYq9y4PUhTGKo4,5400
 dscan_api_client/api/tasks/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dscan_api_client/api/tasks/tasks_create.py,sha256=emwVUkVQ3SYT5kc_tX0yMFbIfEpkV8W2JpeCdwbkMdI,4466
+dscan_api_client/api/tasks/tasks_create.py,sha256=-FkFk-9vWDeVTZ28amc1RrEUNCcPkMyiJw5KS2owpoc,3804
 dscan_api_client/api/tasks/tasks_destroy.py,sha256=-VSVJmHB4a4SbNCc8QXuP1msEx7l0UmcjvZTxT7-IYw,2553
 dscan_api_client/api/tasks/tasks_list.py,sha256=rzQNsj4-_bAJAtzVN8ZSK1cvXDTFci56EP97Qcvu4BA,3624
-dscan_api_client/api/tasks/tasks_partial_update.py,sha256=8Y0MZggg4NWOgQMzQ37wrbMdXmDQQOuKZ-lZCwB_Zf4,4883
+dscan_api_client/api/tasks/tasks_partial_update.py,sha256=IpvVFaIQ_trDLOJ9VsIZid3tAVeGjdrtChm3Q_phOk0,4123
 dscan_api_client/api/tasks/tasks_retrieve.py,sha256=z0VPPbHX1SMlX7m7ArOPyebYbFSYcwYm9JOyoK2pt6s,3608
-dscan_api_client/api/tasks/tasks_update.py,sha256=8GINY0kTKSYeZWuo8dk7_qmuLhdquDwDiqyCKVtsHJ0,4673
+dscan_api_client/api/tasks/tasks_update.py,sha256=w4yZ-j0lTHAv6qeoPmSJAWkzfFyWr7cRy1uqNeZBNs0,4011
 dscan_api_client/models/__init__.py,sha256=b8jdVUzIxG-FoopJOsLnmrRAoE35WAr_wpHfbhZVa7k,1027
-dscan_api_client/models/patched_program.py,sha256=GzeaWfdjxSffYU7ZawF6qVysT6__JmjwbLAisNQIulg,6120
-dscan_api_client/models/patched_scan.py,sha256=-z5bXe_tVuS2D5BjC7Q4UgHlVM19-NPejkKQUu6SJc8,7372
-dscan_api_client/models/patched_scanner.py,sha256=Gki2kiQeoNRAMN_y63IwKT_yTGis52AJA5BEehreLB4,5478
-dscan_api_client/models/patched_subdomain.py,sha256=iZqYrpeUhGkpAjhNHnHHKvw7ft9JUH7StySUlaUMcyk,6411
-dscan_api_client/models/patched_task.py,sha256=40DfB6a9SLAWMMEb2N1cfwaDhvMCa4AiGz4-QLrMVp8,6075
-dscan_api_client/models/program.py,sha256=uuBWGZOH7CAOM8egYOVuouP6as4tTZ3uy8ODn8rjsow,4149
-dscan_api_client/models/program_subdomain_check.py,sha256=Hux3AQ2mIRlIqLtxR7HEXwIbRWvxdw287F4sb2WxtwE,2017
-dscan_api_client/models/scan.py,sha256=bX-KZIrwS3I3eaBKyTcchjow3m1iYx7eUGowFQ9UIa8,6021
-dscan_api_client/models/scanner.py,sha256=JdzuHafuanXA5wrBGCV7Oe4yeFpzmrAYDYbinIDXE2Y,4515
+dscan_api_client/models/patched_program.py,sha256=7oFfXZ0uoscGaW3xQYblFsNigPM0tjT8qasC0llL6y8,4083
+dscan_api_client/models/patched_scan.py,sha256=silT08cjGsBNVJ5BnEgPZDnKdPOufdFytYsEcedv8n8,4808
+dscan_api_client/models/patched_scanner.py,sha256=oZPLqBiQza8BksAvNtk3u1hATKuV0XgFE2OpFeHqxp8,3625
+dscan_api_client/models/patched_subdomain.py,sha256=iwnFCsVfn_drxf09SVGLfkmgtwrpkLWWGj11kv5tIWI,4255
+dscan_api_client/models/patched_task.py,sha256=5leZLio0_lWwDM4bGkiZqM1---F_yloFlexfLykmWHM,4050
+dscan_api_client/models/program.py,sha256=AgYDxbl2kJQ-F2rcbkLvQJw-v1Yc3bxyCnFTCTdTaTc,2709
+dscan_api_client/models/program_subdomain_check.py,sha256=mWGjYDQb1sjAnQH1wqY_d_kmc_p_ELRRdpY84jPGPfM,1502
+dscan_api_client/models/scan.py,sha256=8i_csaRg7U4XRTg1iOrOQBL-om0iXB9_7V9nFchasog,3830
+dscan_api_client/models/scanner.py,sha256=VI3Ny-LNqJVKjUW3sbpHkaNW_vmZdfrg3_6uJlgieZI,2929
 dscan_api_client/models/schema_retrieve_format.py,sha256=TZnuYsQovAhJH6yWQdTEKuv-nFptwrH8BAT8Oo6IVmo,161
 dscan_api_client/models/schema_retrieve_response_200.py,sha256=BCcdR4bmr33kI5gxkKaW9ph8ehBBSOkAG1iDETOY5ZM,1223
-dscan_api_client/models/subdomain.py,sha256=h-6ZO5k91xWqoQkQs5x6J2hwD9XrUYSuWo46Y1TZ5mU,5052
+dscan_api_client/models/subdomain.py,sha256=cU9fRCmYbVgDBGFZM7Lz9FmjfMVB-4_zftfwJJqeN0M,3273
 dscan_api_client/models/subdomain_detail.py,sha256=OkX29lGJ3DkJ5Trjw5LQ0TlK683zqkxkld5KKelx2jI,4439
 dscan_api_client/models/subdomain_with_detail.py,sha256=pFhXPyPExQvNjE4uGBYUYHbGG9Cx82RiQrlkvNoW7w8,3801
-dscan_api_client/models/task.py,sha256=nwXJ2nFjsR1QM21k7-OAkWYF0kv09FxB5cUL40o-mI0,4718
-dscan_api_client-1.0.0.dist-info/LICENSE,sha256=7JuEYZMQLxf4ua7slkSRlLByIyRoX8lpKWrelO0DFls,1065
-dscan_api_client-1.0.0.dist-info/METADATA,sha256=bX-E_54PC7DP_q_4JjYqQ0L5YAttg7EWzhjiCDZlBHs,4090
-dscan_api_client-1.0.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-dscan_api_client-1.0.0.dist-info/top_level.txt,sha256=ZyZ73BiwBjY66XykOEQ07AWiAED-1-ccKyLtssnbuVg,17
-dscan_api_client-1.0.0.dist-info/RECORD,,
+dscan_api_client/models/task.py,sha256=Rd3dgvtEu8C4T9Pmp7Dbcutqzu1SyFv4MYWGEYUopRM,3069
+dscan_api_client-1.0.1.dist-info/LICENSE,sha256=7JuEYZMQLxf4ua7slkSRlLByIyRoX8lpKWrelO0DFls,1065
+dscan_api_client-1.0.1.dist-info/METADATA,sha256=4osRa1jMiEzvIIAaswC8uZTUxw61jYPVwsAITus1m60,4090
+dscan_api_client-1.0.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+dscan_api_client-1.0.1.dist-info/top_level.txt,sha256=ZyZ73BiwBjY66XykOEQ07AWiAED-1-ccKyLtssnbuVg,17
+dscan_api_client-1.0.1.dist-info/RECORD,,
```

